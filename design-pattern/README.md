## Design Pattern QnA

### Q. 디자인 패턴
A. 디자인 패턴이란 요리 레시피에 비유할 수 있다. 실제 개발 현장에서 만들어진 다양한 해결책 중 best practice를 정리한 것이다.

### Q. 어댑터 패턴
A. 어댑터를 번역하면 변환기라고 할 수 있다. 변환기의 역할은 서로 다른 두 인터페이스 사이 통신이 가능하게 해준다. 어댑터 패턴은 호출당하는 쪽의 메소드를 호출하는 쪽 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴이다.

### Q. 프록시 패턴
A. 프록시는 다른 누군가를 대신해 그 역할을 수행하는 존재를 말한다. 그래서 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴이다.

### Q. 데코레이터 패턴
A. 원본에 장식을 더하는 패턴이다. 프록시 패턴과 구현 방법이 똑같은데, 프록시 패턴은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달하는 반면 데코레이터 패턴은 반환값에 장식을 덧입힌다.

### Q. 싱글톤 패턴
A. 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하기 위한 패턴이다. 인스턴스가 필요할 때 똑같은 인스턴스를 새로 만드는 것이 아닌 기존의 인스턴스를 활용하는 것이다. 예를 들어, 로그를 남길 때마다 로거 객체를 생성해서 사용한다면 힙에 객체를 계속 할당하니까 자원을 그만큼 소모하는 것이다. 따라서 단 하나의 로거 객체만 만들어서 로그를 남길 때마다 같은 객체를 가져다 사용한다. (private 생성자, 정적 변수로 객체 생성, 정적 메소드로 객체 반환)

### Q. 이터레이터 패턴
A. 무언가 많이 모여있는 것을 하나씩 지정해서 순서대로 처리하는 패턴이다. For문에서 변수 i의 역할을 추상화한 것으로 보면 된다. 하나씩 꺼내서 처리하는 과정을 구현과 분리할 수 있다.

### Q. MVC 패턴
A. 하나의 애플리케이션을 만들 때 구성 요소를 Model, View, Controller 세 가지 역할로 구분하는 패턴이다. 사용자가 컨트롤러에 요청하면 컨트롤러는 모델을 통해 데이터를 가져오고 해당 정보를 뷰를 통해 사용자에게 전달한다. 컨트롤러만 모델이나 뷰에 대해 알고 있고, 나머지는 서로의 구성 요소들을 몰라야 한다.

### Q. 템플릿 메소드 패턴
A. 특정 환경 상황에 맞게 확장, 변경할 때 유용한 패턴이다. 추상 클래스, 구현 클래스 둘로 구분한다. 장점은 구현 클래스에는 추상 클래스에 선언된 메소드만 사용하므로 핵심 로직 관리가 용이하며 객체 추가 및 확장이 가능하다. 단점은 추상 메소드가 많아지면, 클래스 관리가 복잡하다.

### Q. 팩토리 메소드 패턴
A. 객체를 만드는 부분을 Sub 클래스에 맡기는 패턴이다. 생성하는 클래스를 따로 만들며 그 클래스는 부모 클래스를 상속하고 있기 때문에 반드시 선언해야 한다. 정리하면 생성하는 객체를 별도로 두며 그 객체에 넘어오는 값에 따라서 다른 것을 만들어 낸다.

### Q. 옵저버 패턴
A. 상태를 가지고 있는 주체 객체 상태의 변경을 알아야 하는 관찰 객체이다. 1대1, 1대N 관계이다. 서로의 정보를 주고받는 과정에서 정보의 단위가 클수록, 객체들의 규모가 클수록 복잡성이 증가하게 된다. 이때 가이드라인을 제시해줄 수 있는 것이 옵저버 패턴이다. 구독자, 고객들은 정보를 얻거나 받아야 하는 주체와 관계를 형성하게 된다. 관계가 지속되다가 정보를 원하지 않으면 해제할 수도 있다. 이때 객체와의 관계를 맺고 끊는 상태 변경 정보를 옵저버에 알려줘서 관리하는 것을 말한다.

옵저버 패턴은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고, 자동으로 정보가 갱신된다. 인터페이스를 통해 연결하여 느슨한 결합성을 유지하며 Publisher와 Observer 인터페이스를 적용한다. 하지만 Observable 클래스로 구현되어 있기 때문에 사용하려면 상속을 해야한다. 따라서 다른 상속을 함께 이용할 수 없는 단점이 존재한다.

### Q. 스터레티지 패턴
A. 어떤 동작을 하는 로직을 정의하고, 이것들을 하나로 묶어 관리하는 패턴이다. 새로운 로직을 추가하거나 변경할 때 한번에 효율적으로 변경이 가능하다.
