## Operating System QnA

### Q0. 운영체제의 정의와 목적은 무엇인가?

운영체제는 하드웨어와 소프트웨어를 연결하는 소프트웨어 계층이다. 좁은 의미로는 커널 및 운영체제의 핵심 부분으로 메모리에 상주하는 부분이며 넓은 의미로는 커널 및 각종 주변 시스템 유틸리티를 포함하는 개념이다. 운영체제의 목적은 시스템의 자원을 효율적으로 관리하는 것이다.

### Q1. 운영체제 처리방식 3가지는 무엇인가?

운영체제에는 Batch Processing(일괄 처리 방식), Time Sharing(시분할), Realtime OS가 있다. 일괄 처리 방식은 작업 요청의 일정량을 모아서 한꺼번에 처리하며, 작업이 완전히 종료될 때까지 기다린다. 시분할 방식은 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 나누어 사용한다. 일괄 처리 시스템에 비해 짧은 Response time을 가지며, Iteractive 한 특징을 갖고 있다. 실시간 OS는 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 운영체제이다. 특수한 목적을 가질 때 사용한다.

### Q2. 여러 작업을 동시에 수행하는 용어 네 가지에 대해 설명하시오.

운영체제 기본 용어는 `Multitasking`, `MultiProgramming`, `Time Sharing`, `MultiProcessor` 네 가지가 있다. Multitasking은 CPU는 한 번에 하나의 작업만 수행할 수 있는데, 이 시간이 아주 짧아 동시에 수행되는 것처럼 보이는 것이다. MultiProgramming은 메모리에 여러 프로그램이 올라가 있는 것이며 Time Sharing은 CPU의 시간을 나누어 쓴다는 의미를 강조하는 것이다. MultiProcessor는 컴퓨터 한 대에 CPU가 여러 개 있는 것을 말한다.

### Q3. 유닉스 운영체제와 MS Window 운영체제의 특징에 대해 설명하시오.

유닉스 운영체제는 CLI 기반의 운영체제이다. CLI란 `Command-Line Interface`로 명령어 기반으로 컴퓨터가 상호작용하는 의미이다. 유닉스 운영체제는 터미널을 통해 컴퓨터가 상호작용을 하며, 대부분의 코드는 C로 작성되어 있고, 코드를 공개한다. 다수의 사용자가 이용할 때 좋으며 이식성이 좋다.

MS Window 운영체제는 GUI 기반의 운영체제이다. GUI란 `Graphic-User Interface`로 사용자가 편리하게 사용할 수 있도록 입출력 등의 기능을 알기 쉬운 아이콘 따위의 그래픽으로 나타낸 것이다.

### Q4. 컴퓨터 시스템 구조와 설명하시오.

메모리는 CPU의 작업 공간이다. CPU는 평생 메모리에만 접근하여 명령어를 실행하는 일만 한다. 하나의 명령어를 처리하면 `Program Counter`를 1 증가 시켜 다음 명령어를 수행한다. CPU는 Device에 접근할 때 직접 접근하지 않고 `Device Controller`에게 요청한다.

### Q5. Mode bit에 대해 설명하시오.

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치가 필요했다. `Mode bit`을 통해 하드웨어적으로 두 가지 모드의 `operation`을 지원한다. mode bit이 0일 경우에는 모니터 모드로 OS(커널) 코드를 수행하는 것이다. mode bit이 0일 경우에는 운영체제가 CPU를 가지고 있기에, 모든 명령어를 수행할 수 있다. mode bit이 1일 경우에는 사용자 모드로 사용자 프로그램을 수행하고 있는 것이다. 사용자 프로그램 수행 도중 `Exception`이나 `Interrupt` 발생 시 하드웨어가 mode bit을 0으로 수정한다. OS에서는 사용자 프로그램에 CPU를 넘기기 전에 mode bit을 1로 세팅한다.

### Q6. Timer에 대해 설명하시오.

특정 프로그램이 CPU를 독점하는 것을 보호한다. 타이머는 Time Sharing을 구현하기 위해 널리 이용되며, 현재 시간을 계산하기 위해서 사용된다. 정해진 시간이 흐른 뒤에 운영체제에게 제어권이 넘어가도록 Interrupt를 발생시킨다. 타이머는 매 클럭 틱때마다 1씩 감소하며 값이 0이 되면 Timer Interrupt를 발생시킨다.

### Q7. Device Controller에 대해 설명하시오.

`Device Controller`는 I/O 장치 유형을 관리하는 일종의 CPU이다. Device Controller는 `Local buffer`와 제어 정보를 위한 `Control register`를 갖는다. 화면에 출력할 데이터는 Local buffer에 저장하며 실제 화면에 출력하라는 명령은 Control register에서 수행한다. 그래서 I/O는 실제 Device와 Local buffer 사이에서 상호작용이 일어나며 Device Controller는 입출력이 끝났을 경우 Interrupt를 발생시켜 CPU에게 그 사실을 알린다.

### Q8. Device Memory Access Controller에 대해 설명하시오.

원래는 CPU만 Memory에 접근할 수 있다. 하지만 그렇게 될 시에 Interrupt의 발생 빈도가 증가한다. 왜냐하면 I/O 요청이 끝날 때마다 Interrupt를 걸어주기 때문에, CPU가 아무리 빨라도 비효율적으로 일을 수행할 것이다. 그래서 Direct Memory Access Controller이 등장하였고 I/O 작업을 메모리에 직접 접근하여 실행하고, CPU에게 Interrupt를 한 번만 걸어주어 발생 빈도를 감소시킨다.

### Q9. 입출력 수행에 대해 설명하시오.

입출력 명령어는 특권이다. 따라서 OS가 CPU를 잡고 있을 때 요청이 가능하다. 사용자 프로그램을 수행하고 있을 때 입출력 요청이 필요하면 Interrupt를 발생시켜 OS에게 CPU 제어권을 넘긴다. 이 용어를 시스템 콜이라고 한다. 그럼 CPU는 인터럽트가 발생한 특정 위치로 이동하며 인터럽트 서비스 루틴으로 이동한다. 그런 다음 입출력 명령이 올바른지 확인하고 수행 후 제어권을 시스템 콜 다음 명령어를 수행한다.

### Q10. Interrupt에 대해 설명하시오.

Interrupt는 두 가지로 나뉜다. 하드웨어가 발생시킨 Interrupt는 말 그대로 Interrupt라 하며, 소프트웨어가 발생시킨 Interrupt는 `Trap`이라 하며 사용자 프로그램이 발생시킨 Interrupt이다. Trap은 또 두 가지로 나뉘는데 System Call과 Exception으로 나뉜다. System Call은 사용자 프로그램이 커널 함수를 호출하기 위해 자발적으로 Interrupt를 발생시킨 것이며, Exception은 프로그램이 오류를 범한 경우이다.

### Q11. 동기식 입출력과 비동기식 입출력에 대해 설명하시오.

사용자 프로그램 수행 중에 I/O 요청을 하면 CPU 제어권이 OS에게 넘어간다. 이때 I/O 요청이 끝날 때까지 제어권을 들고 있고 끝난 후에 CPU 제어권을 넘겨주는 것이 동기식 입출력이며 요청만 한 후에 끝나는 것을 기다리지 않는 것이 비동기식 입출력이다.

### Q12. 프로그램이 실행될 때 어떻게 메모리에 올라가는지 설명하시오.

프로그램이 실행되면 프로그램을 위한 주소가 0번부터 할당이 되고, 다른 프로그램이 실행되면 다른 프로그램을 위한 주소가 0번부터 할당이 된다. 이 메모리를 `Virtual Memory`라 하며 그 구조는 `stack` `data` `heap` `code`로 되어있다. 당장 필요한 프로그램만 메모리에 올리고 나머지는 Disk에 내려둔다. 사용자 프로그램에서 시스템 콜을 하면 커널 모드로 들어간다. 응답이 오면 다시 사용자 모드로 돌아가고 다시 커널 모드로 반복을 실행하고 프로그램 종료 시 끝난다.

### Q13. 사용자 프로그램이 사용하는 함수는 어디에 들어가는지 설명하시오.

사용자 정의 함수와 라이브러리 함수는 자신이 실행시킨 프로세스의 code 영역, 커널 함수는 커널의 code 영역에 들어간다.

### Q14. 프로세스의 개념에 대해 설명하시오.

프로세스는 실행중인 프로그램을 의미한다. 프로세스의 문맥(context)는 CPU 현재 상태를 나타내기 위해 필요한 모든 요소들이다.

### Q15. 프로세스의 각각의 상태에 대해 설명하시오.

프로세스의 상태는 `New`, `Ready`, `Running`, `Terminated`, `Blocked`, `Suspended`가 있다. 앞에서부터 설명하면 New는 프로세스가 생성 중인 상태, Ready는 프로세스가 메모리에 올라와 CPU를 기다리는 상태, Running은 CPU를 잡고 명령어를 수행 중인 상태, Terminated는 프로세스가 종료된 상태이다. Blocked는 프로세스가 어떤 이벤트가 완료될 때까지 기다리는 상태이며 이벤트가 완료되면 Ready로 이동한다. Suspended는 외부적인 이유로 프로세스의 수행이 정지된 상태로 중기 스케줄러에 의해 swap out이 된 상태이다. 다시 메모리로 올리려면 외부에서 resume을 해주어야 한다.

### Q16. PCB에 대해 설명하시오.

PCB는 Process Control Block으로 CPU에 의해 실행 중인 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조이다.

### Q17. 문맥 교환(Context Switch)에 대해 설명하시오.

CPU는 아주 빠르다. 그래서 한 프로세스가 CPU를 독점하는 것이 아닌 짧은 시간 간격으로 교환이 일어난다. 프로세스가 CPU를 빼앗기고 다시 얻었을 때 다시 처음부터 실행하는 것이 아닌, CPU를 넘겨줬을 때 시점부터 실행하는 것이다. 하지만 시스템 콜이나 Interrupt가 발생 시 반드시 Context Switch 일어나는 것이 아니다. 프로세스가 시스템 콜을 했을 때 프로세스의 상태가 Blocked 되어 당장 명령어 수행이 불가능하다. 따라서 이와 같은 경우에는 커널에서 사용자 모드로 돌아올 때 Context Switch가 일어난다.

### Q18. CPU 스케줄러에 대해 설명하시오.

CPU 스케줄러는 장기, 단기, 중기로 나뉜다. 장기 스케줄러는 어떤 프로세스를 메모리로 올릴지 결정하는 스케줄러이며, 단기 스케줄러는 CPU 제어권을 누구에게 줄지 결정하는 것이다. 중기 스케줄러는 여유 공간 마련을 위해 프로세스 통째로 메모리에서 swap out 시키는 것이다. 지금의 시스템은 장기 스케줄러 없이 시작하면 일단 메모리를 할당해 준다. 이 경우 너무 많은 프로그램이 메모리에 올라가면 문제가 될 수 있다. 이러한 것을 조절해 주는 것이 중기 스케줄러이고, 스와퍼가 일부 프로그램을 메모리에서 쫓아낸다.

### Q19. 쓰레드에 대해 설명하시오.

쓰레드는 프로세스 하나에 CPU 수행 단위만 여러 개를 두고 있는 것이다. Virtual Memory 중 stack 부분만 독립적으로 가지며, 나머지 부분은 공유한다. 다중 쓰레드로 구성된 테스크 구조에서는 하나의 서버 쓰레드가 Blocked 상태인 동안에도 동일한 테스크 내의 다른 쓰레드가 실행되어 빠른 처리를 할 수 있다. 동일한 일을 수행하는 다중 쓰레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.

### Q20. 쓰레드 이점에 대해 설명하시오.

쓰레드 이점에는 대표적으로 4가지가 있다. `Responsiveness`, `Resource Sharing`, `Economy`, `Utilization of MP Architectures`이다. Responsiveness는 응답성으로 웹 브라우저가 여러 쓰레드를 갖고 있으면 한 쓰레드가 이미지 서버에 이미지 파일을 다시 요청했을 때 다른 쓰레드가 이미 렌더링 한 html 텍스트라도 화면에 보여줌으로써 사용자는 더 빨리 화면을 볼 수 있다. 던져놓고 실행한다고 보면 된다. 쓰레드는 stack 부분을 제외한 나머지 부분을 공유한다. 따라서 각종 자원을 공유함으로써 효율적으로 사용할 수 있다. 또한 프로세스를 하나 생성하는 것보다 쓰레드를 하나 더 만드는 것이 간편하다. 문맥 교환 또한 오버헤드가 프로세스가 더 크다. 이유는 프로세스 내부에서 쓰레드 간 CPU Switching은 동일한 주소 공간을 쓰고 있다. MP는 MultiProcessor의 약자로 컴퓨터에 여러 개의 CPU가 있는 것이다. 따라서 각각의 쓰레드가 서로 다른 CPU에서 병렬적으로 일을 할 수 있다.

### Q21. 프로세스와 쓰레드의 차이점에 대해 설명하시오.

프로세스는 실행 중인 프로그램이며, 쓰레드는 프로세스의 실행 단위를 뜻한다. 프로세스는 Virtual Memory, 즉 code data heap stack을 독립적으로 갖는다. 하지만 쓰레드는 stack을 제외한 나머지 부분을 공유한다. 그래서 쓰레드를 여러 개 생성해서 사용하는 멀티 쓰레드에서는 자원 생성과 관리의 중복을 최소화한다는 장점이 있지만 동기화 문제를 해결해 줘야 한다.

### Q22. CPU 스케줄링에 대해 설명하시오.

여러 종류의 프로세스가 섞여 있기 때문에 CPU 스케줄링이 필요하다. CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용해야 한다. CPU 스케줄링은 CPU 제어권을 어떤 프로세스에게 줄지 결정하는 것이다. 결정을 하면 CPU 제어권을 넘겨주는 데 이것을 `Dispatcher`라고 한다. CPU 스케줄링이 필요한 경우는 Runnig 중인 프로세스가 시스템 콜을 요청할 때나 할당 시간 만료로 Ready 상태로 돌아갈 때, Blocked 된 프로세스가 이벤트 완료로 Ready인 상태, 프로세스가 종료된 상태에 스케줄링이 필요하다.

### Q23. CPU 스케줄링의 성능척도에 대해 설명하시오.

첫 번째로 `CPU Utilization`, 즉 CPU 이용률이다. CPU 이용률은 CPU가 놀지 않고 일한 시간의 비율을 뜻한다. 두 번째로 `Throughput`은 주어진 시간 동안 몇 개의 일을 처리했냐의 성능 척도이며, `Turnaround time`은 한 개의 일이 시작되고 끝날 때까지 걸린 시간이다. `Waiting Time`과 `Response Time`은 비슷한 의미인데 전자는 프로세스가 레디 큐에서 기다린 시간이고, 후자는 처음 CPU를 얻기까지 걸린 시간이다.

### Q24. FCFS에 대해 설명하시오.

CPU 스케줄링 중 하나로써 First-come First-Serve 즉, 먼저 들어온 것을 먼저 처리하는 알고리즘이다. 비선점형이지만, CPU를 오래 쓰는 프로세스가 먼저 와서 할당받으면 나머지 프로세스들은 전부 기다려야 하기 때문에 비효율적이다.

### Q25. SJF에 대해 설명하시오.

SJF는 Shortest Job First로 선점형과 비선점형으로 나뉜다. 우선 선점형은 현재 레디 큐에 있는 것들 중 CPU를 가장 짧게 사용하는 프로세스에게 CPU 제어권을 넘긴다. 비선점형은 수행 중에, 더 짧은 프로세스가 등장하면 그 프로세스에게 CPU 제어권을 넘기며 이 용어를 Shortest Remaining Time Frist라고 부른다. 효율적이긴 하지만 `Starvation` 현상이 발생할 수 있다. 스타베이션은 CPU burst time이 긴 프로세스는 계속 CPU를 못 잡는 현상이다.

### Q26. Priority Scheduling에 대해 설명하시오.

우선순위 스케줄링은 말 그대로 각각의 프로세스에게 우선순위를 부여해 가장 높은 프로세스에게 CPU 제어권을 주는 것이다. 하지만 이것도 `Starvation`이 발생할 수 있지만 `Aging` 기법으로 해결할 수 있다. 에이징은 오랫동안 CPU를 잡지 못한 프로세스의 우선순위를 높여주는 것이다.

### Q28. Round Robin에 대해 설명하시오.

각 프로세스마다 동일한 시간을 할당한다. 할당 시간이 지나면 프로세스는 선점 당하고 레디 큐의 제일 뒤에 가서 줄을 선다. 즉, Response Time이 빨라진다. 할당 시간을 Time Quantum이라고 하는데, 이 Time Quantum이 작으면 문맥 교환 오버헤드가 커진다. 큰 경우에는 FCFS 형태가 된다.

### Q29. Multi-Level Feedback Queue에 대해 설명하시오.

레디 큐를 여러 개 두어 우선순위를 부여하는 것은 Multi-Level Queue이다. MLFQ는 프로세스가 다른 큐로 이동이 가능한 형태이다. MLFQ 방식으로 처음에 Time Quantum을 짧게 하고, 뒤로 갈수록 길게 설정하여 aging이 구현이 가능하다. MLFQ를 정의하는 파라미터로는 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 보내는 기준, 프로세스를 하위 큐로 보내는 기준, 프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준이 필요하다.

### Q30. 운영체제에서 데이터의 연산은 어떻게 되는지 설명하시오.

운영체제에서 데이터는 연산을 수행하는 곳과, 데이터를 저장하는 공간으로 나뉜다. 데이터를 저장하고 있는 공간에서 데이터를 가져와 연산을 수행하는 공간에서 연산을 수행 후 데이터를 저장한다.

### Q31. Race Condition에 대해 설명하시오.

운영체제에서는 데이터를 저장하는 공간과 연산을 수행하는 공간이 나뉜다고 했다. 하지만 저장 공간을 공유하고, 연산하는 공간이 각각 나누어져 있는 경우 같은 데이터를 사용하려고 할 때 발생하는 것이 Race Condition, 즉 경쟁 상태이다. Race Condition을 해결하기 위해서는 동기화 문제를 해결해야 한다.

### Q32. OS에서의 Race Condition이 일어나는 경우 3가지에 대해 설명하시오.

첫 번째로 커널에서 수행 중에 Interrupt 발생 시 일어난다. 커널에서 count++을 수행하던 도중 아직 값을 저장하지 않은 상태에서 Interrupt가 발생하여 수행을 멈추고, Interrupt로 넘어가게 된다. 이때 Interrupt에서 count--을 수행하고 다시 커널로 돌아와 count++ 된 값을 저장하면 count는 원래의 값이 있어야 하는데, 뒤에 수행된 count++ 된 값이 저장이 된다. 이런 경우, Interrupt가 발생해도 커널에서 중요한 변수의 값을 작업하던 일이 저장이 될 때까지 수행될 수 있게끔 `disable` 해주어서 경쟁 상태를 막을 수 있다.

두 번째로 프로세스가 시스템 콜을 호출하여 커널 모드로 수행 중인데 문맥 교환이 일어나는 경우이다. 커널 모드에서 count++ 연산 수행 도중에 time quantum이 끝나서 CPU를 빼앗긴다. CPU를 점유한 프로세스가 count를 1 증가시키고 다시 돌려주는데, 이때 최종 연산 결과는 2가 되어야 하는데 1만 증가하게 된다. CPU를 다시 할당받았을 때 그 시점의 context를 가지고 값을 증가시켰기 때문에 그렇다. 이를 해결하기 위해서는 커널 모드에서 프로세스가 수행 중일 때는 CPU 할당 시간이 끝나도 선점하지 않고 다시 사용자 모드로 돌아갔을 때 선점한다. (커널 - 비선점, 사용자 - 선점)

세 번째로 MultiProcessor에서 공유 메모리 내의 커널 데이터를 사용할 때이다. 이때는 위의 방법들로는 전혀 해결이 되지 않기 때문에 CPU가 공유 데이터를 사용한다면 lock을 걸어 다른 CPU가 접근해도 접근할 수 없게 한다. 그리고 메모리에 저장할 때 unlock을 하여 다른 CPU가 접근하게 해줄 수 있다. 한 번에 하나의 CPU만 커널에 들어가게 하는 경우는 비효율적이기에 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 것이 효율적이다.

### Q33. Race Condition 프로그램적 해결법 충족 조건에 대해 설명하시오.

공유 데이터 부분을 임계 영역이라고 한다. 그래서 어떤 프로세스가 임계 영역 부분을 수행 중이라면 다른 프로세스는 임계 영역에 들어가면 안 된다. 또한 아무도 임계 영역에 없을 때는 들어갈 수 있게 해주어야 하며 기다리고 있는 프로세스들이 허용될 때까지 다른 프로세스들이 임계 영역에 들어가는 횟수는 한계가 있어야 한다.

### Q34. lock/unlock과 block/wakeup이 어떤 경우에 사용해야 효율적인지 설명하시오.

일반적으로 lock/unlock이 CPU를 더 의미 있게 사용하기 때문에 일반적으로 더 효율적이다. 하지만 임계 영역의 길이가 긴 경우에는 block/wakeup이 적당하며 길이가 짧은 경우에는 오버헤드가 busy-wait 오버헤드보다 커질 수 있다.

### Q35. Deadlock에 대해 설명하시오.

일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 말한다.

### Q36. Deadlock 발생의 4가지 조건에 대해 설명하시오.

Mutual exclusion, 매 순간 하나의 프로세스만이 자원을 사용할 수 있게 설정하거나 No Preemption, 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않거나 Hold and wait, 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있거나 Circular wait, 자원을 기다리는 프로세스 간에 사이클이 형성되어야 할 때 Deadlock이 발생한다. 위의 4가지 조건 중 하나라도 만족하지 않으면 발생하지 않는다.

### Q37. Deadlock 처리 방법에 대해 설명하시오.

Deadlock을 처리하는 방법은 대표적으로 4가지가 있다.

첫 번째로 Deadlock Prevention이다. 자원 할당 시 Deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 것이다. 두 번째로 Deadlock Avoidance, 자원 요청에 대한 부가적인 정보를 이용해서 가능성이 없는 경우에만 자원을 할당한다. 세 번째로 Deadlock Detection and Recovery, Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 발견 시 recover 한다. 마지막으로 요즘 시스템에서 사용하는 Deadlock Ignorance로, Deadlock을 시스템이 책임지지 않는다. Deadlock은 매우 드물게 발생하기 때문에 조치를 취하는 것이 오히려 더 큰 오버헤드일 수 있기 때문이다.

### Q38. Virtual Address vs Physical Address 

Virtual Address는 프로세스마다 독립적으로 가지는 주소 공간이다. 각 프로세스마다 0번지부터 시작하며 CPU가 보는 주소이다. Physical Address는 메모리에 실제 올라가는 위치이다. 특정 프로그램이 물리적인 메모리에 어디에 올라갈지 결정하는 것을 주소 바인딩이라고 한다.

### Q39. 주소 바인딩의 종류에 대해 설명하시오.

Complie time binding은 물리적 메모리 주소가 컴파일 시 알려진다. 메모리를 재할당 할 때 다시 컴파일 해야 하기 때문에 비효율적이다. Load time binding은 Loader 책임하에 물리적 메모리 주소를 부여한다. 컴파일러가 재배치 가능한 코드를 생성한 경우 가능하다. Excution time binding은 수행이 시작된 이후에도 프로세스의 메모리상 위치를 옮길 수 있다. CPU가 주소를 참조할 때마다 binding을 점검한다. 하드웨어적인 지원이 필요하다.

### Q40. MMU에 대해 설명하시오.

MMU는 Memory Management Unit의 약자로 Virtual Address를 Physical Address로 매핑해주는 하드웨어 장치이다. base register와 limit register를 이용해 virtual address 값을 base register 값을 더해서 변환한다. CPU가 논리 주소를 요청하면 limit register를 통해 프로그램보다 더 큰 논리 주소를 요청한 것은 아닌지 확인한다.

### Q41. Dynamic Loading에 대해 설명하시오.




