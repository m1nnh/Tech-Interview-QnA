## Database QnA

### Q. 데이터베이스 키
A. 데이터베이스에서 키란 검색 정렬 시 튜플을 구분할 수 있는 기준이 되는 속성이다. 후보키는 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합이다. 즉 기본키로 사용할 수 있는 속성들을 말한다. 하나의 테이블 내에서는 중복된 튜플들이 있을 수 없으므로 모든 테이블에는 반드시 하나 이상의 후보키가 존재한다. 후보키는 테이블에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.

기본키는 후보키중 선택한 메인키다. 널 값을 가져서는 안되며 동일한 값이 중복될 수 없다. 대체키는 후보키 중 기본키를 제외한 나머지 키이다. 보조키라고도 불린다.

슈퍼키는 한 테이블 내에 있는 속성들의 집합으로 구성된 키로써 테이블을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타나지 않는다. 슈퍼키는 테이블 구성하는 모든 튜플에 대해 유일성을 만족시키지만, 최소성은 만족시키지 못한다. 외래키는 관계를 맺고 있는 테이블 키다.

### Q. 조인
A. 관계형 데이터베이스에서는 중복 데이터를 피하기 위해서 데이터를 쪼개 여러 테이블로 나누어서 저장한다. 이렇게 분리되어 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서는 여러 테이블을 조합할 필요가 있다. 관계형 데이터베이스에서는 조인 연산자를 사용해 관련 있는 칼럼을 기준으로 행을 합쳐주는 연산이다.

### Q. SQL Injection
A. 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법이다. Error based SQL Injection은 논리적 에러를 이용한 것이며 가장 많이 쓰이고 대중적인 공격, 기법이다. Union based SQL Injection은 Union 명령어를 이용한 것이다. Union 명령어는 두 개의 쿼리문에 대한 결과를 통합해서 하나의 테이블로 보여주는 키워드이다. 유니온 인젝션이 성공하기 위해서는 두 테이블의 칼럼 수와 데이터 형이 같아야 한다.

방어 대책으로는 값을 받을 때 검증을 하고, 또한 에러시 해당하는 에러 메시지를 감춘다. 그리고 특수문자들을 자동으로 제거해주는 Preparestatement를 사용한다.

### Q. SQL vs NoSQL
A. SQL을 이용하면 RDBMS에서 두 데이터를 저장, 수정, 삭제 및 검색을 할 수 있다. 관계형 데이터베이스에서는 핵심적인 두 가지 특징이 있는데, 데이터는 정해진 스키마에 따라 테이블에 저장되며 데이터는 관계를 통해 여러 테이블에 분산된다.

NoSQL은 SQL을 사용하지 않는 것이다. 따라서 스키마도 없고 관계도 없다. NoSQL에서는 레코드를 문서라고 부른다. NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다. 따라서 여러 테이블을 조인할 필요 없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. 자주 변경되지 않는 데이터일 때 사용하면 효율적이다.

### Q. 수직적 확장 / 수평적 확장
A. 수직적 확장은 단순히 데이터베이스 서버의 성능을 향상시키는 것이며, 수평적 확장은 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미한다. SQL은 일반적으로 수직적 확장만 지원하며 NoSQL은 둘다 가능하다.

### Q. SQL의 장단점
A. 명확하게 정의된 스키마, 데이터 무결성 보장, 관계는 각 데이터를 중복없이 한번만 저장한다. 단점은 스키마를 사전에 계획하고 알려야 하므로 덜 유연하다. 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리를 만들 수 있으며 대체로 수직적 확장만 가능하다.

관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우나, 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우 SQL을 이용하며, 복잡한 조인문을 만들지 않고 설계하여 단점을 제거한다.

### Q. NoSQL의 장단점
A. 장점은 스키마가 없어서 유연하다. 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다. 데이터는 애플리케이션이 필요로 하는 형식으로 저장이된다. 데이터를 읽어오는 속도가 빨라지며 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기, 쓰기 요청 처리가 가능하다.

단점은 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있다. 데이터 중복을 계속 업데이트 해야 한다. 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 한다.

따라서 정확한 데이터 구조를 알 수 없거나, 변경, 확장될 수 있는 경우나, 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우에 사용한다.

### Q. 인덱스
A. 관계형 데이터베이스에서 검색 속도를 높이기 위한 기술이다. 데이터베이스 안의 집합을 처음부터 풀 스캔하지 않고, B+ Tree로 구성된 구조에서 인덱스 파일 검색으로 속도를 향상하는 기술이다. 테이블을 생성할 때 FRM/MYD/MYI 파일이 생성된다. FRM 파일은 테이블 구조 저장 파일이며, MYD는 실제 데이터 파일, MYI는 인덱스 파일이다. 사용자가 쿼리를 통해 index를 사용하는 테이블을 검색하게 되면 MYI 파일의 내용을 활용한다.

### Q. 인덱스의 장단점
A. 인덱스 생성시 파일 크기가 증가하며, 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다. 인덱스 된 속성에서 데이터를 업데이트 하거나 ,집합을 추가 또는 삭제시 성능이 떨어진다. 데이터 변경 작업이 자주 일어나는 경우 인덱스를 재작성해야 하므로 성능에 영향을 미친다.

따라서 어느 속성을 인덱스 해야 하는지 미리 시험해 보고 결정하는 것이 좋다. 인덱스를 추가하면 쿼리 속도가 1초 정도 빨라지지만, 데이터 행을 추가하는 속도는 2초정도 느려지게 되어 여러 사용자가 사용하는 경우 집합 잠금 문제가 발생할 수 있다.

장점은 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다. 질의나 보고서에서 그룹화 작업의 속도를 향상시키며 인덱스를 사용하면 테이블 행의 고유성을 강화시킨다.

### Q. 인덱스 사용상황 분석
A. 사용하면 좋은 경우는 where절에서 자주 사용되는 컬럼, 외래키가 사용되는 컬럼, 조인에 자주 사용되는 컬럼에 사용한다. 반대로 데이터 중복도가 높은 컬럼이나 DML이 자주 일어나는 컬럼은 피한다.

### Q. DML이 일어났을 때의 상황
A. Insert는 새로운 block을 할당 받은 후 Key를 옮기는 작업을 수행한다. 인덱스 split 작업 동안, 해당 block key 값에 대해서 DML이 블로킹 된다. (대기 이벤트 발생) 테이블에서 데이터가 삭제되는 경우는 데이터가 지워지고, 다른 데이터가 그 공간을 사용 가능하다. 인덱스에서 데이터가 삭제되는 경우는 데이터가 지워지지 않고 널 값 표시만 해둔다. 테이블에서 업데이트가 발생하면 인덱스는 업데이트할 수 없다. 인덱스에서는 삭제가 발생한 후 새로운 작업의 삽입 작업을 해야한다. (2배)

### Q. 트랜잭션
A. 트랜잭션이란 데이터베이스 상태를 변화시키는 하나의 논리적인 작업 단위이다. 더 쉽게 표현하자면 한꺼번에 수행되어야 할 일련의 연산인데, 주로 데이터 부정합을 방지하기 위해 사용한다.

트랜잭션은 4가지 특징을 갖고 있다. 원자성이란 트랜잭션이 분해할 수 없는 작업의 최소 단위로 all or nothing 전략을 취한다는 뜻이다. 일관성은 트랜잭션 수행 전후 데이터가 모순되지 않고 일관성 있어야 한다는 뜻이며, 격리성은 트랜잭션이 실행되는 도중에 다른 연산이 끼어들지 말아야 한다는 뜻이다. 영속성은 트랜잭션 정상 종료 후 영구적으로 디비에 반영되어야 한다는 것이다.

### Q. undo / redo
A. 트랜잭션과 무관하게 버퍼의 상태에 따라 버퍼 교체가 일어나는데 이로 인해 정상적으로 종료 되지 않은 트랜잭션이 변경한 페이지들은 원상 복구되어야 하는데 이 복구를 undo, 이미 commit한 트랜잭션의 수정을 재반영하는 복구 작업을 redo라고 한다.

### Q. Isolation Level
A. 트랜잭션의 격리 수준은 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 테이블을 볼 수 있게 할지 말지 결정하는 것이다. 크게 네 단계로 구성되며 뒤로 갈수록 고립성은 높아지지만 성능은 떨어진다.

Read Uncommittted, 트랜잭션 변경내용이 커밋이나 롤백됨에 상관없이 다른 트랜잭션에서 값을 읽을 수 있다. 하지만 읽어들인 값이 실제 변경된 테이블에 존재하지 않는 값이 될 수 있어 dirty read가 발생할 수 있다.

Read Committed, 트랜잭션 변경내용이 커밋되어야만 다른 트랜잭션에서 값을 읽을 수 있다. Repeatable read 정합성에 어긋난다. Repeatable read란 한 트랜잭션 내에서 select 할때마다 같은 결과를 받아와야 함을 뜻한다.

Repeatable Read, 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 값을 읽을 수 있다. 트랜잭션은 각각 고유한 트랜잭션 번호를 갖고 있는데, 이 번호는 트랜잭션이 시작될 때마다 순차적으로 증가한다. 하지만 같은 쿼리를 두 번 실행했을 때 처음에는 없었던 레코드가 나타나는 phantom read 문제가 있다.

Serializable, 가장 단순하고 엄격한 격리 수준이다. phantom read 문제를 해결했으나 동시 처리 성능이 가장 낮아 거의 사용하지 않는다.
