## Problem Solved

[프로그래머스 Level 1 카카오 문제 풀이](https://github.com/m1nnh/Tech-Interview-QnA/tree/master/Algorithm/Level1)

[프로그래머스 Level 2 카카오 문제 풀이](https://github.com/m1nnh/Tech-Interview-QnA/tree/master/Algorithm/Level2)

[프로그래머스 Level 3 카카오 문제 풀이]()

[프로그래머스 Level 3까지 전체 문제 풀이](https://github.com/m1nnh/Problem-Solving/tree/master/Programmers)

## Algorithm QnA 

### Q0. 알고리즘 공부는 어떻게?

올해 초 2월부터 알고리즘 공부를 시작했습니다. 그전까지 주 언어는 C언어였는데, C언어로 코딩 테스트를 치르기는 시간이 오래 걸렸고, 저의 역량 또한 높지 않았기 때문에 비교적 쉬운 언어를 선택하려고 했습니다. 그러다 친구의 추천으로 파이썬을 접했고, 파이썬 문법부터 공부를 시작했습니다.

파이썬 문법과 알고리즘 이론을 공부할 때는, 이것이 취업을 위한 코딩 테스트다 나동빈 저자의 책을 이용했습니다. 기본적인 문법과, 주요 알고리즘 설명과 코드로 되어있어 이해하기 쉬웠습니다. 2주일 동안, 책을 완독 했고 그 이후부터 7월까지는 꾸준히 백준 문제를 풀었습니다. 문제를 풀 때 기준은 시간을 재면서 풀고, 시간이 넘어가면 해답을 보고 주말에 다시 풀어보는 방식으로 했습니다. 그리고 상반기 때 몇몇 회사의 코딩 테스트를 치렀습니다. 결과는 좋지 않았고, 그때 저는 공부 방법이 잘못됐다고 느껴 공부 방법을 바꾸게 되었습니다. 일단 시간을 기준으로 두지 말고, 풀 수 있을 때까지 스스로 풀었습니다. 그리고, 에디터를 사용하지 않는 프로그래머스에서 직접 문제를 풀며 실제 코딩 테스트를 준비했습니다. 결과적으로 프로그래머스 레벨 3까지 문제를 다 풀었고, 해답을 본 문제는 3문제 밖에 되지 않았습니다. 문제를 다 푼 이후에도 풀면서 시간이 오래 걸렸던 것들 위주로 문제를 다시 풀며 복기했습니다.

### Q1. 시간복잡도, 공간복잡도는 무엇인가?

복잡도는 알고리즘의 성능을 나타내는 척도입니다. 그중에서 시간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미합니다. 공간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미합니다. 동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘입니다. 범위에 따른 시간 복잡도는 다음과 같습니다.

- N의 범위가 500인 경우 : O(N<sup>3</sup>)인 알고리즘을 설계하면 풀 수 있습니다.
- N의 범위가 2,000인 경우 : O(N<sup>2</sup>)인 알고리즘을 설계하면 풀 수 있습니다.
- N의 범위가 100,000인 경우 : O(NlogN)인 알고리즘을 설계하면 풀 수 있습니다.
- N의 범위가 10,000,000인 경우 : O(N)인 알고리즘을 설계하면 문제를 풀 수 있습니다.

공간 복잡도는 128 ~ 512MB정도로 제한하는 것으로 알고 있습니다.

### Q2. 코딩 테스트를 치루면서 가장 어려웠던 알고리즘?

특정 알고리즘을 이용해서 푸는 문제면 어렵지 않았습니다. 하지만 까다로운 구현과 시뮬레이션, DP가 조금 어려웠습니다. 기본적으로 수학에 조금 약해서 DP의 규칙을 찾아도 점화식을 찾아내는 것이 어려웠으며, 구현과 시뮬레이션 같은 경우 조건을 하나라도 빼먹으면 틀리기 때문에 어려웠습니다. 그래서 구현과 시뮬레이션 연습 문제를 풀 때 최대한 처음 제출한 코드가 정답이 되도록 꼼꼼하게 한 번 더 코드를 봤으며 출력을 통해서 원하는 값이 정확히 들어가고 나오는지, 체크하면서 문제를 접근했습니다.

### Q3. 그리디 알고리즘에 대해 설명하시오.

그리디 알고리즘은 단어 그대로 번역하여 **탐욕법**입니다. 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘입니다. 여기서 탐욕적이라는 말은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 의미합니다. 정렬과 최단 경로 알고리즘도 그리디 알고리즘에 속합니다. 보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하는 것으로 알고 있습니다.

### Q4. 구현에 대해 설명하시오.

구현이란 **머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정**입니다. 흔히 문제 해결 분야에서 구현 유형의 문제는 **풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제**를 의미합니다. 코딩 테스트에서 주로 구현 문제를 중심으로 출제가 되는 것으로 알고 있습니다. 구현 문제를 풀 때는 프로그래밍 언어의 문법을 정확히 알고 있어야 하며 문제의 요구사항에 어긋나지 않는 답안 코드를 실수 없이 작성해야 합니다. 구현의 시퀀스는 Problem -> Thinking -> Solution입니다. 

### Q5. DFS/BFS에 대해 설명하시오.

`DFS`는 Depth-First Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다. DFS 문제의 유형들은 그래프 문제에서 주로 출제가 됩니다. 그래프는 노드와 간선으로 표현되며 이때 노드를 정점이라고 합니다. 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있습니다.

- 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
- 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

인접 행렬 같은 경우 연결이 되어 있지 않은 노드끼리는 무한의 비용이라 작성하며, 인접 리스트의 경우에는 연결 리스트 자료구조를 이용해 구현합니다. 동작 과정은 

- 탐색 시작 노드를 스택에 삽입하고 방문 처리합니다.
- 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리, 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
- 위의 과정을 더 이상 수행할 수 없을 때까지 반복합니다.

`BFS`는 Breadth-First Search, 너비 우선 탐색이라는 의미를 가집니다. 쉽게 말해 자신에 인접한 노드부터 방문하는 알고리즘입니다. DFS는 루트 노드로부터 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다면, BFS 그에 반대입니다. 따라서 BFS는 stack으로는 구현할 수 없으며 queue 자료구조를 이용하여 구현합니다. queue는 선입선출 방식입니다. 동작 과정은 

- 탐색 시작 노드를 큐에 삽입하고 방문 처리합니다.
- 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리합니다.
- 위의 과정을 더 이상 수행할 수 없을 때까지 반복합니다.

### Q6. 정렬에 대해 설명하시오.

정렬 방법은 여러 가지가 있습니다.

#### Bubble Sort 

버블 정렬은 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘입니다. 시간 복잡도의 경우 최선, 최고, 최악의 경우 모두 O(N<sup>2</sup>)로 동일합니다. 공간 복잡도는 주어진 배열을 통해 교환되므로 O(n)입니다.

#### Selection Sort 

선택 정렬은 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘입니다. 자릿 수마다 가장 최소 값을 찾아 해당하는 인덱스에 넣습니다. 시간 복잡도와 공간 복잡도는 버블 정렬과 동일합니다.

#### Insertion Sort 

삽입 정렬은 2번째 원소부터 시작하여 그 앞의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘입니다. 위의 두 정렬과는 다르게 최선의 경우 O(N)이라는 엄청나게 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘입니다.

#### Quick Sort 

퀵 정렬은 위의 정렬과는 다른 시퀀스로 진행이 됩니다. 우선 피벗을 선택한 후, 오른쪽에서 왼쪽으로 가면서 피벗보다 작은 수를 찾고 왼쪽에서 오른쪽으로 가면서 피벗보다 큰 수를 찾아 두 원소를 교환합니다. 이 과정을 반복하다 보면, 왼쪽엔 피벗보다 작은 값, 오른쪽엔 큰 값들만 존재하게 됩니다. 퀵 정렬의 경우 평균적으로 O(NlogN)의 시간 복잡도를 갖지만, 이미 어느 정도 정렬되어 있는 경우, 즉 최악의 경우에는 O(N<sup>2</sup>)의 시간 복잡도를 갖습니다.

#### Merge Sort 

파이썬에서 sort 함수는 병합 정렬로 되어있습니다. 요소를 쪼갠 후, 다시 합병시키면서 정렬해 나가는 방식으로 퀵 정렬과 유사합니다. 퀵 정렬은 피벗을 통해 영역을 쪼개지만, 병합 정렬은 영역을 쪼갤 수 있을 만큼 쪼갠 후에 정렬을 합니다. 이미 병합의 대상이 되는 두 영역이 각 영역에 대해서 정렬이 되어있기 때문에 단순히 두 배열을 순차적으로 비교하면서 정렬할 수가 있습니다. 병합 정렬은 순차적인 비교로 정렬을 진행하므로, 링크드 리스트의 정렬이 필요할 때 사용하면 효율적입니다. 시간 복잡도는 O(NlogN)을 갖습니다.

#### Count Sort 

계수 정렬은 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성하고, 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키는 정렬입니다. 계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘입니다. 데이터의 개수가 N, 데이터 중 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행 시간 O(N + K)를 보장합니다. 다만, 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능합니다. 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있습니다.

### Q7. 이진 탐색에 대해 설명하시오.

이진 탐색은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘입니다. 이진 탐색은 위치를 나타내는 변수 3개를 사용하며, 탐색하고자 하는 범위의 시작점, 끝점, 그리고 중간점입니다. 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것이 이진 탐색 과정이다.

### Q8. 다이나믹 프로그래밍은 언제 사용하는가?

컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킵니다. 그래서 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 합니다. 그런 방법이 다이나믹 프로그래밍 또는 동적 계획법이라고 표현합니다.

### Q9. 메모이제이션 기법에 대해 설명하시오.

기본적으로 다이나믹 프로그래밍은 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서 동일하다는 조건을 가지고 있습니다. 따라서 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 메모이제이션 즉 캐싱이라고도 부릅니다.

### Q10. 최단 경로에 대해 설명하시오.

최단 경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘입니다. 예를 들어 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우입니다.

#### 다익스트라 알고리즘 

다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘입니다. 다익스트라 최단 경로 알고리즘은 **음의 간선**이 없을 때 정상적으로 동작합니다. 매번 가장 비용이 적은 노드를 선택하기 때문에 그리디 알고리즘으로도 분류됩니다. 따라서 우선순위 큐인 heapq를 이용해서 구현할 수 있습니다. 알고리즘의 원리는 

- 출발 노드를 설정합니다.
- 최단 거리 테이블을 초기화합니다.
- 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
- 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신합니다.
- 위에 3번 4번 과정을 반복합니다.

#### 플로이드 워셜 알고리즘

플로이드 워셜 알고리즘은 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우에 사용할 수 있는 알고리즘입니다. 각각의 노드마다 최단 거리를 구해야 하므로 시간 복잡도는 O(N<sup>3</sup>)의 복잡도를 갖습니다.

