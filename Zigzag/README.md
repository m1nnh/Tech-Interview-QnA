## 지그재그 프로젝트 QnA

### Q. Project Architecture
A. EC2 Service에서 서버를 구축하고 nginx를 node.js 앞단에서 프록시 서버로 사용했다. 데이터베이스는 따로 분리해서 RDS에서 MySQL을 사용했다.

### Q. EC2 사용과 데이터베이스 분리 이유
A. 서버를 자신의 컴퓨터에 구축을 하게 되면, 컴퓨터가 켜져 있지 않으면 서버는 자동적으로 꺼지게 된다. 그래서 가상의 컴퓨터를 빌려와서 그 공간에서 서버를 구축하려고 EC2를 이용했다. 과거에는 서버-클라이언트 구조에서 서버와 데이터베이스가 따로 분리되어 있지 않았다. 하지만 데이터베이스의 크기가 커지게 되면, 트래픽을 분산시키기 위해 동일한 시스템의 서버와 데이터베이스를 확장시켜야 되기 때문에 커다란 데이터베이스 서버 1개를 구축하고 여러 개의 웹서버를 구축하는 방식으로 시스템이 바뀌었다. 즉, 여러 개의 서버를 구축하고 서로 다른 서버는 하나의 큰 데이터베이스를 공유하는 것이다. 그래서 데이터베이스를 분리하였다. (보안적 측면에서도 안전)

### Q. Nginx 사용 이유
A. 대표적인 웹서버로는 아파치와 nginx가 있다. nginx를 사용한 이유는 이벤트 기반 비동기 처리 구조로 다수의 연결을 보다 효과적으로 처리할 수 있고, 아파치보다 동작이 단순하고 빠르다고 하여 reverse proxy로 사용했다. 이벤트 기반 비동기 처리 구조는 여러 클라이언트의 요청을 하나의 쓰레드로 처리하며 각각의 요청에서 이벤트가 발생할 때만 그에 맞는 작업을 처리하는 구조이다.

### Q. Apache
A. 아파치는 프로세스/쓰레드 기반 구조로 기본적으로 하나의 쓰레드가 하나의 요청을 처리한다. 따라서 요청이 많아질 경우 그만큼 시스템 자원을 소모한다. (안정성과 확장성 측면에선 우수)

### Q. Web Server / Web Application Server
A. web server는 정적 컨텐츠, 즉 파일 경로 이름을 받아와 해당 경로와 일치 하는 페이지를 제공해주거나 동적 컨텐츠에 대한 요청을 전달해준다. 반면 WAS는 데이터베이스의 조회나 다양한 로직 처리에 대한 동적 컨텐츠를 제공해준다.

### Q. Nginx 처리 방식
A. nginx는 이벤트 기반 비동기 처리 방식으로 동시 처리에 특화된 웹 서버 프로그램이다. 하나의 master process와 여러 개의 worker process로 구성되어 실행된다는 특징이 있다. master process는 nginx configuration 파일을 읽고 실행하며 work process를 관리하고, 실질적인 요청에 대한 처리는 worker process가 한다.

### Q. Nginx Configuration?
A. nginx 모듈들은 configuration 파일 안에 있는 directive에 의해 제어된다. directive는 크게 simple directive와 block directive로 나뉜다. simple directive는 단순하게 한 줄로 선언되는 반면 block directive는 중괄호에 의해 감싸진다. 대표적인 block directive로는 http block, server block, location block이 있다.

http block은 웹 트래픽을 처리하며 server block은 하나의 웹 사이트를 선언 하는 데 사용되는 가상  호스트이다. 가상 호스트란 한 대의 컴퓨터로 여러 대의 컴퓨터가 존재하는 것처럼 동작하는 것을 말한다. location block에서는 특정 디렉토리에 대한 요청을 처리하는데, nginx는 가장 구체적인 매치에 대한 요청을 처리하는 것으로 알고 있다. 프로젝트 진행시 sites-available 폴더에 config 파일을 생성해 sites-enabled 폴더로 심볼릭 링크를 걸어 사용했다.


### Q. Hard link / Symbolic link
A. 링크는 호환성을 유지하기 위해 혹은 깊이가 깊은 디렉토리에 있는 파일을 간단하게 접근하기 위해 사용하는 것으로 알고 있다. Hard link는 원본 파일의 inode를 직접적으로 가리킨다. 따라서 원본 파일이 사라지더라도 실제 데이터만 남아있다면 사용할 수 있다. 반면 Symbolic link는 원본 파일의 이름을 가리킨다. 쉽게 말해 윈도우 바로가기와 비슷하다. 그래서 원본 파일이 삭제되면 무용지물이 된다.

### Q. Inode
A. Inode는 파일 시스템에서 사용되는 자료구조로 파일에 대한 각종 정보를 담고 있다. i는 index를 뜻하는데 배열에서 인덱스로 원소에 접근하듯이 파일 시스템에서는 inode를 통해 실제 데이터에 접근한다.

### Q. Reverse Proxy
A. 프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램을 가리킨다. 서버와 클라이언트 사이에 중계 역할을 하며 forward proxy와 reverse proxy로 나뉜다.

forward proxy는 클라이언트 요청이 실제 서버에게 직접 전송되는 것이 아니라 프록시 서버가 받아 요청을 전달하는 것이다. 서버 입장에서는 프록시 서버로부터 요청받기 때문에 실제 클라이언트에 대한 정보를 알 수 없다.

reverse proxy는 클라이언트 요청을 프록시 서버가 받아 뒷단에 있는 실제 서버로부터 데이터를 받아와 클라이언트에게 응답해주는 방식이다. 클라이언트 입장에서는 프록시 서버에게 요청하고 응답을 받기 때문에 실제 서버에 대한 정보를 알 수 없다. 

### Q. 프록시 서버의 장점
A. 프록시 서버를 사용하면 보안, 성능, 트래픽 분산에서 장점을 가질 수 있다.

보안 측면에선, 프록시 서버를 사용하면 클라이언트나 서버 모두 IP를 숨길 수 있는 방법이 생긴다. 실제 서버 또는 클라이언트의 IP를 숨기고 프록시 서버의 IP만 공개함으로써 해킹을 대비할 수 있다.

성능 측면에선, 프록시 서버를 사용하여 캐싱 기능을 사용해 성능 향상을 가져올 수 있다.

트래픽 분산 측면에선, 일부 프록시 서버는 로드 밸런싱을 제공하는데, 여러 대의 분산된 서버가 있다면 서버의 트래픽을 분산시켜 준다. 그리고 end-point(URL)마다 호출하는 서버를 설정할 수 있어 역할에 따라 서버의 트래픽을 분산시킬 수도 있다.

### Q. 로드 밸런싱
A. 로드 밸런싱은 말 그대로 부하를 분산시키는 것이다. 클라이언트와 서버가 일대일로 매칭되어 있고 요청에 대한 응답을 충분히 해줄 수 있으면 괜찮다. 하지만 서버 자원이 무수히 많은 요청을 견디기 힘들 때 트래픽에 대처하기 위해 서버 성능을 올리는 scale up을 하거나 서버 개수를 늘리는 scale out을 해줘야 하는데 후자가 바로 로드 밸런싱이다.

L4 로드 밸런싱은 Transport 계층에서 트래픽을 분산하는 방법이다. 데이터를 직접 보지 않고 패킷 레벨에서만 분산하기 때문에 빠르고 비용이 저렴하다. 반면 L7 로드 밸런싱은 Application 계층에서 트래픽을 분산한다. 패킷 내용을 확인하고 내용에 따라 특정 서버로 보낼 수 있는데, 섬세한 라우팅이 가능하나 패킷을 다시 복호화해야 하기 때문에 더 많은 비용이 발생한다.

### Q. letsencrypt / certbot
A. letsencrypt는 SSL 인증서를 무료로 발급해주는 CA 기관이다. 여기서 사용을 권장하는 프로그램이 certbot이고, certbot을 이용하면 인증서 갱신을 쉽게 할 수 있다. certbot 명령어를 사용하면 4개의 pem 파일이 생성되는데 그 중 서명된 인증서와 letsencrypt의 중간 인증서가 합쳐진 fullchain 파일과 인증서의 개인키 파일을 nginx 서버 블록에 세팅해줬다.

### Q. SSL / TLS
A. SSL은 Secure Socket Layer의 약자로 클라이언트와 서버 간 보안을 위한 프로토콜이다. 1.0 버전은 대중에게 공개되지 않고 2.0부터 공개됐는데, 공개하고 보니 보안상 취약점이 많아 얼마 지나지 않아 SSL 3.0을 공개했고, 이것을 표준화한 프로토콜이 TLS이다. TLS가 조금 더 많은 경고 코드를 포함하고 있고, SSL과는 서로 상호 운용되지 않는다. 요즘 사용하는 SSL은 대부분 TLS인 것으로 알고 있다.

### Q. SSL 인증서
A. SSL 인증서는 클라이언트와 서버 사이 통신을 공인된 제 3자가 보증해주는 문서이다. 여기서 제 3자란 주로 Certificate Authority, 즉 인증 기관이다. 인증서에는 공개키나 유효 기간, 발급자 등의 정보가 담겨 있다. SSL 인증서는 통신 내용이 노출되거나 변경되는 것을 방지함과 동시에 해당 서버가 신뢰할 수 있는 서버임을 보장해준다.

### Q. SSL 통신
A. SSL도 TCP 프로토콜을 기반으로 하기 때문에 3 way handshake 과정이 선행된다. 클라이언트가 랜덤 데이터를 생성해 자신이 사용할 수 있는 암호화 방식들과 함께 서버로 보낸다. 서버 또한 랜덤 데이터를 생성하고 사용할 암호화 방식과 SSL 인증서를 클라이언트에게 보낸다.

클라이언트는 인증서의 CA를 자신이 들고 있는 CA 리스트에 있는지 확인하고, 이싸면 인증서의 공개키로 복호화한다. 공개키로 복호화한다는 것은 인증서가 CA 비밀키로 암호화  됐다는 것을 뜻하며 이는 곧 인증서의 신원을 보증해준다.

클라이언트는 자신이 생성하고 서버로부터 받은 랜덤 데이터를 조합하여 임시 키를 발급하는데, 이를 공개키로 암호화해서 서버에게 다시 보낸다. 서버는 자신의 비밀키로 이를 복호화할 수 있고 이로써 클라이언트와 서버 모두 동일한 임시 키를 갖고 있게 된다.

양쪽 모두 일련의 과정을 거쳐 세션 키를 생성하고, 이 키를 활용하여 대칭키 암호화 방식으로 데이터를 주고 받는다. 결론적으로 SSL 통신은 공개키 암호화 방식과 대칭키 암호화 방식을 모두 활용한다.

두 방식을 조합해서 사용하는 이유는 대칭키 암호화 방식의 경우 빠르지만 키가 노출되면 누구나 복호화할 수 있다. 그래서 채널을 수립할 때에는 공개키 암호화 방식을 사용해서 안전하게 수립하고, 실제 데이터를 주고 받을 때 대칭키 암호화 방식을 이용한다.

### Q. Node.js
A. node.js는 자바스크립트 런타임으로, 쉽게 말해 웹 브라우저가 아닌 곳에서 자바스크립트를 실행할 수 있게 해주는 자바스크립트 실행기이다. 기본적으로 싱글 쓰레드를 사용하고, 이벤트 기반 비동기 처리 방식이다. 그래서 입력은 하나의 쓰레드에서 받지만 순서대로 처리하지 않고 먼저 처리된 결과값을 이벤트로 변환한다는 특징이 있다.

### Q. Blocking / Non-blocking / 동기 / 비동기
A. Blocking은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 말하며 Non Blocking은 이전 작업이 끝날 때까지 기다리지 않고 다음 작업을 수행하는 것을 뜻한다.

동기와 비동기는 시간 측면에서 보면 이해하기 쉬운데, 두 개의 작업이 있을 때 서로의 시작이나 종료에 상관없이 작업을 수행하면 비동기, 시작이나 종료가 똑같거나 하나의 작업이 끝나자마자 다른 작업이 수행되면 동기이다.

### Q. Framework / Library
A. 프레임워크는 프로그래밍 시 뼈대나 구조를 제공해주는 클래스와 인터페이스의 집합체이며 라이브러리는 프로그램 기능 수행을 위한 함수의 집합이다. 둘은 흐름을 누가 갖고 있느냐로 쉽게 구분할 수 있는데, 프레임워크는 자체적으로 흐름을 갖고 있어 개발자가 그 안에서 마치 뼈대에 살점을 붙이는 방식으로 개발한다. 반면 라이브러리는 흐름을 개발자가 가진 채 원할 때마다 라이브러리를 사용하는 개념이다.

### Q. 단일 쓰레드 / 멀티 쓰레드
A. 단일 쓰레드는 하나의 프로세스에서 하나의 쓰레드만을 생성해서 사용하는 것이다. 자원 접근에 대한 동기화를 신경쓰지 않아도 되고, 쓰레드 간 context switching 비용도 발생하지 않는다. 하지만 여러 개의 CPU를 활용할 수 없다는 단점이 있다. 반대로 멀티 쓰레드는 프로세스를 실행 단위로 나누어 실행하는 것인데, 자원을 공유하기 때문에 자원 생성과 관리의 중복을 최소화한다. 보통 프로세스 간 context switching보다 쓰레드 간 context switching이 프로세스를 새로 생성하는 것보다 쓰레드를 새로 생성하는 것이 훨씬 빠르다. 하지만 공유 자원에 접근하기 때문에 동기화 문제를 해결해줘야 한다.

### Q. REST API
A. REST란 필요한 자원에 접근하는 방식을 정해놓은 규칙이다. URI를 통해 자원을 명시하고, HTTP 메소드를 통해 자원에 대한 연산을 처리한다. REST에는 여러 가지 설계 규칙이 있는데, 이러한 규칙을 잘 지켜서 작성한 API를 REST API 혹은 RESTful한 API라고 한다.

### Q. 어려웠던 점
A. 구현하는 데 있어서는 스토리가 어려웠다. 예를 들어, 어떤 사용자가 스토리를 3개 생성했는데 그 중 2개를 보고 1개를 안봤다고 가정을 해보면, 처음 목록을 조회할 때 안본 스토리가 있기 때문에, 그것을 표시해주어야 하고, 스토리를 봤을 때, 안본 스토리먼저 나온 후 본 스토리가 사용자가 올린 순서대로 나와야 하는 것이었다. 그래서 이 부분을 총 세 단계로 나누어서 접근했다.

첫 번째로 가장 첫 번째 스토리를 조회하는 부분이다. 스토리를 조회 했던 항목이 있으면, 먼저 만들어진 순서대로 뒤로 넣고, 조회 안한 항목이 있으면 처음으로 조회 될 수 있도록 처리했다.

두 번째로 특정 스토리를 조회하는 API이다. 첫 번째 스토리 조회 이후 다음 항목을 조회하기 위해서이다. 그래서 첫 번째 스토리를 조회 했을 때 결과 값으로 다음 스토리 인덱스 값을 넘겨줬다.

마지막으로 화면에 보이는 스토리 목록을 조회하는 API인데, 노드 안에서 밸리데이션을 통해, 스토리를 전부 조회하지 않거나 전부 조회한 것을 처리했다.

기술적으로는 필터링이 어려웠다. 단순히 정렬을 위한 필터링은 괜찮았은데, 스토어 탭에서 상품이 대분류, 중분류, 소분류로 나눠져 있는데 이 부분이 어려웠다. 예를 들어 상의 -> 티셔츠 -> 무지 티셔츠 순으로 타고 들어간다고 치면 누를때마다 조회되는 상품들이 해당 분류에 맞게 계속 바뀌었다.

그래서 카테고리 테이블을 어떻게하면 좋을까 고민하다가 status로 대분류/중분류/소분류를 구분하고, 상위 분류를 가리킬 수 있는 reference 칼럼을 추가했다.

예를 들어 대분류 번호가 1~5, 중분류가 6~15, 소분류가 16~30 이라면 대분류의 reference는 자기 자신이 되고 중분류의 reference는 해당하는 대분류 번호를, 소분류의 reference는 해당하는 중분류 번호를 가리키게 했다.

이후 쿼리 스트링으로 대분류만 받는 경우 대분류 중분류 받은 경우, 대분류 중분류 소분류 전부 받은 경우마다 where 절만 다르게 쿼리를 작성했다. 이렇게 만든 이유는 굳이 API를 나누지 않고 하나로 필터링을 이용해 처리하고 싶었기 때문이다.

### Q. 아쉬웠던 점
A. 아쉬웠던 점은 스케줄링을 이용한 푸시알림을 구현하지 못했다. 그래서 프로젝트가 끝난 후에 Test Code 작성 연습과 스케줄링을 이용해 푸시알림을 구현했다.

### Q. 푸시 알림과 스케줄링
A. 푸시 알림은 Firebase Cloud Messaging을 사용했다. 앱이 켜지는 스플래시 화면에서 클라이언트로부터 fcm 토큰을 받아온다. 이 토큰을 데이터베이스에 저장해뒀다가 푸시 알림이 필요한 경우 해당 사용자의 fcm 토큰으로 알림 메시지를 보냈다.

실제 앱에 사용한 것은 아니고 테스트를 위해 구현해봤다. 시간을 설정해 스케줄러를 통해 테스트 메시지를 알림으로 보내는 연습을 했다. 스케줄링은 cron을 이용했다. cron은 유닉스 계열 운영체제의 시간 기반 스케줄러로 6개의 단위 문자를 이용하여 cron 표현식을 만들고, 이를 스케줄러로 활용할 수 있다. node-schedule 모듈에 있는 scheduleJob 함수에 표현식을 넣어 해당 시간이 되면 콜백 함수가 실행되게끔 했다. (그리고 로그인이 30일 지난 사용자가 있다면 데이터베이스에서 자동로그인을 풀어주는 과정 또한 스케줄링 처리해줬다.)

### Q. Test Code
A. 테스트 코드 작성은 Nest.js를 사용했다. Nest.js를 사용한 이유는 Node.js의 프레임워크인 Express만을 이용하여 Node.js 개발을 하다보면 다른 언어에서는 차마 볼 수 없는 자유에 취하다가, 모든 것을 개발자에게 맡기는 그 자유때문에 서비스의 규모가 커질수록 유지보수, 테스트가 어려워지고 코드도 난해해지기 일쑤다. 그래서 Typescript를 적용해서 Node.ts 환경으로 코드를 작성하면 훨씬 나아지지만, 초기 설정에는 시간과 비용이 든다. 그래서 그 모든 비효율을 잡아주는 프레임워크가 Nest.js이기 때문에 사용했다.

Nest.js의 테스트 종류에는 네 가지가 있다. 유닛 테스트, 엔드 투 엔드 테스트, 부하 테스트, 스트레스 테스트가 있다. 먼저 유닛 테스트는 함수 단위의 작은 코드를 테스트 하며, 유닛 테스트가 톱니바퀴에 나사가 잘 끼워졌는지, 윤활은 잘 되어있는지 등을 검사한다면 엔드 투 엔드 테스트는 톱니바퀴가 잘 돌아가는 그림 정도를 보는 것이다. 즉 처음부터 끝까지 실행이 되는 것을 테스트하는 것이다. 부하 테스트와 스트레스 테스트는 얼마나 많은 동시 접속자를 처리할 수 있는지 테스트하는 것이다.

나는 Jest를 이용해 유닛 테스트와 엔드 투 엔드 테스트를 수행하며 개발 당시 미처 생각하지 못한 부분들에 대한 케이스가 나올 때마다 흔히 말하는 TDD, 즉 테스트 주도 개발이 왜 중요한지 깨달았다. 처음부터 완벽한 설계를 하는 것은 불가능하므로 실패할 케이스들을 먼저 고려했다면 훨씬 수월하지 않았을까 싶다.

### Q. winston (log)
A. 로그를 남기기 위해 winston과 winston-daily-rotate-file 모듈을 사용했다. 후자를 이용해서 하루 단위로 새 로그 파일을 생성하고 하루가 지나면 파일을 압축했다.

winston의 로그 레벨은 0부터 6까지 7단계가 있는데, API에 대응되는 함수에서 catch문에 잡히는 것만 error로 표시하고 나머지는 info 단계로 로그를 남겼다. info는 로그인, 상태 변경과 같은 정보성 메시지를 나타낸다. 실제로 API가 호출될 때 파라미터가 제대로 전달되는지를 확인했다.

### Q. axios (Open Auth)
A. axios HTTP 요청과 응답을 JSON으로 변경해주는 통신 라이브러리이다. 카카오 로그인을 구현할 때 사용했는데, 클라이언트로부터 Access Token을 받고 내가 다시 카아오 서버에게 해당 Access Token을 줄 때 사용했다. 카카오 서버 입장에서 자신이 발급한 토큰이 맞으면 사용자에 대한 정보를 주기 때문에 이것을 받아 데이터베이스에 저장하고 JWT를 발급해서 로그인시켰다.
