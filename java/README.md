## Java QnA

### Q. jvm(java virtual machine)

A. jvm은 자바를 실행하기 위한 가상 기계라고 할 수 있다. 자바로 작성된 애플리케이션(application)은 모두 jvm에서 실행되기 때문에 자바(java) 애플리케이션이 실행되기 위해서는 jvm이 필요하다.

### Q. 자바의 장단점

A. 자바의 장단점 모두 jvm을 사용하는데 있다. 우선 장점은, 일반 애플리케이션 코드는 os(operating system)만 거치고 하드웨어(hardware)로 전달 되는데 비해 자바는 jvm 런타임(runtime)에 완벽한 기계어로 변경되어 실행된다. 그래서 jvm하고만 상호작용을 하기 때문에 os와 하드웨어에 독립적이라 다른 os에서도 프로그램 변경없이 실행이 가능하다.(one write use anywhere)

단점은 자바 프로그램이 실행되기 위해서는 먼저 jvm이 실행되어야 하는데 실행과정은 생각보다 많은 메모리(memory)를 소모하며 실행속도 또한 빠르지 않다. 또한 바이트코드(byte-code)를 완전한 기계어로 변환하는 과정에서도 일반적인 컴파일(compile) 언어로 작성된 프로그램(program)보다 속도가 느리다.

### Q. jdk 주요 실행 파일

A.

- javac.exe: 자바 컴파일러(java compiler), 즉 자바 소스코드(source-code)를 바이트코드로 컴파일한다.
- java.exe: 자바 인터프리터(java interpreter)로 컴파일러가 생성한 바이트 코드를 해석하고 실행한다.
- javap.exe: 역어셈블러(disassembler)로, 컴파일된 클래스(class) 파일을 원래의 소스코드로 변환한다.
- jar는 java archive, 자바파일 관련 된 것만 압축, war는 web application archive로 jsp, servlet, jar 등 servlet 관련 파일을 압축

### Q. jdk(java development kit)/jre(java runtime environment)

A. jdk는 자바를 개발하기 위한 환경으로 jre를 포함한다. jre는 자바를 실행시키기 위한 환경으로 jvm을 포함한다.

### Q. jit(just in time)

A. 자바의 실행 과정은 소스코드 -> 컴파일 -> 바이트코드 -> 인터피르터 -> 기계어 -> 실행 순이다. 이 작업은 비용이 많이 들기 때문에 바이트코드를 하드웨어의 기계어로 바로 변환해주는 것이 jit이다. jit 컴파일러는 같은 코드를 매번 해석하는 대신 자주 쓸만한 코드를 컴파일 해두고 사용한다. 이로써 인터프리터의 느린 실행 속도를 개선해 줄 수 있지만, 초기 실행 속도나 메모리 부분에서 약간의 단점이 있다.

### Q. jvm 메모리 구조

A. jvm 메모리 구조는 크게 class, stack, heap, native 메서드, pc 레지스터(register)로 나뉜다.

- class: 클래스, 변수, 메서드, 상수, static 변수에 대한 정보가 저장된다.
- stack: 메서드 호출에 따른 메서드를 위한 공간인 프레임(frame)이 생성되어 메서드 안에서 필요한 각종 값이 임시로 저장된다. 메서드의 수행이 끝나면 프레임별로 삭제가 진행된다.
- heap: new 연산자로 생성된 객체(object)와 배열(array)이 저장되는 공간이다.
  - permanent generation: 생성된 객체들의 주소 값이 저장되는 공간
  - new
    - eden: 객체들이 최초로 생성되는 영역
    - survivor: eden 영역에서 참조되는 객체들이 저장되는 영역
  - old: new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간
- native 메서드: 자바 이외의 다른 언어에서 제공되는 메서드가 저장되는 공간
- pc 레지스터: 쓰레드(thread)가 생성될 때마다 생성되는 영역으로 쓰레드가 어떤 명령을 실행할 지 저장한다.

### Q. 기본 자료형과 참조 자료형

A.

- 기본 자료형: byte, short, int, long, float, double, char, boolean 등이 있으며, 기본 자료형으로 생성한 변수에는 값 자체가 저장된다. 사용 전에 반드시 선언 되어야하며 os에 따라 자료형의 길이가 변하지 않고 널(null) 값을 가질 수 없는 특징이 있다.
- 참조 자료형: class, interface, array, enum 등이 있다. 참조 자료형으로 생성한 변수에는 객체의 주소(address) 값이 저장된다. 생성자를 이용하여 새로운 객체의 주소를 가리키거나 널 값을 이용하여 해제할 수 있다.

### Q. 절차적/구조적 프로그래밍

A.

- 절차적 프로그래밍: 한마디로 goto문을 사용하지 않는 것이다. goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문에 goto를 사용하지 못하게 한 것이다.
- 구조적 프로그래밍: 함수(function)를 쓰라는 의미이다. 함수를 쓰면 좋은 이유는 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 클린코드(clean-code)를 작성할 수 있기 때문이다.

### Q. 객체지향 프로그래밍(object oriented programming)

A. 객체지향 프로그래밍은 객체의 관점에서 프로그래밍(programming)하는 것을 의미한다. 객체지향언어는 기존의 프로그래밍 언어와 다른 전혀 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다. 이러한 규칙들을 이용해서 코드 간에 서로 관계를 맺어줌으로써 보다 유기적으로 프로그램을 구성하는 것이 가능해졌다.

### Q. 객체지향언어 특징

A.

- 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있어 코드의 재사용성이 높다.
- 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있어 관리가 용이하다.
- 제어자(modifier)와 메서드(method)를 이용해서 데이터(data)를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있어, 신뢰성이 높은 프로그래밍을 가능하게 한다.

### Q. 클래스(class)/객체(object)/인스턴스(instance)

A.

- 클래스(class): 객체를 정의해 놓은 것 또는 객체의 설계도 또는 틀 -> 객체를 생성하는 데 사용
- 객체(object): 사전적인 정의는 실제로 존재하는 것(인스턴스를 대표하는 포괄적인 의미)
- 인스턴스(instance): 클래스로부터 객체를 만드는 과정 -> 인스턴스화, 즉 어떤 클래스로부터 만들어진 객체(구체적인 의미)

### Q. 객체의 구성요소

A. 객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 즉 객체는 속성과 기능의 집합이라고 할 수 있다.

### Q. 오버로딩(overloading)

A. 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 오버로딩이라 한다. 오버로딩을 사용하면 메서드의 이름을 절약할 수 있다.

- 오버로딩이 성립하기 위해서는 메서드 이름이 같아야 하며, 매개변수의 개수 또는 타입이 달라야 한다. -> 반환 타입은 영향을 주지 않는다.

### Q. 생성자

A. 생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다. 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다. 생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 리턴 값이 없다는 점이 다르다.

### Q. 상속(inheritance)

A. 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다. 이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.

### Q. 오버라이딩(override)

A. 부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만, 자식 클래스 자신에 맞게 변경해야 하는 경우가 많다.

- 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 부모의 것과 완전히 일치해야 한다.
  - 메서드 이름이 같아야 함
  - 매개변수, 반환 타입이 같아야 함
- 다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.
  - 접근 제어자는 더 좁은 범위는 안되고, 예외는 더 많은 예외를 처리할 수 없다.

### Q. super

A. super는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조 변수이다. 멤버 변수와 지역 변수의 이름이 같을 때 this를 붙여서 구별 했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

### Q. 제어자(modifier)

A. 제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

### Q. 접근 제어자

A. 접근 제어자는 멤버(member) 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

- private: 같은 클래스 내에서만 접근이 가능하다.
- default: 같은 패키지 내에서만 접근이 가능하다.
- protected: 같은 패키지 내에서, 그리고 다른 패키지의 자식 클래스에서 접근이 가능하다.
- public: 접근 제한이 전혀 없다.

접근 제어자를 사용하는 이유는 데이터를 보호하기 위해서다. 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다. 이것을 데이터 감추기라고 하며, 캡슐화(encapsulation)에 해당하는 내용이다.

### Q. static

A. 클래스 내부의 메서드나 멤버 변수에 static 키워드(keyword)를 사용하면 하나의 인스턴스에 속하지 않고 해당 클래스로부터 생성된 모든 인스턴스가 공통으로 공유하는 메서드와 변수로 변경된다.

### Q. final

A.

- 변수: 상수화, 초기화만 가능하며 이후 새로운 값으로 변경이나 재할당 불가능
- 클래스: 해당 클래스는 상속할 수 없음
- 메서드: 오버라이딩 할 수 없음

### Q. getter/setter

A.

- getter: get으로 시작하는 메서드는 단순히 멤버 변수의 값을 반환하는 일을 한다.
- setter: set으로 시작하는 메서드는 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버 변수의 값을 변경한다.

### Q. 다형성(polymorphism)

A. 객체지향 개념에서 다형성(polymorphism)이란 여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현했다. 이를 좀 더 구체적으로 말하면, 부모 클래스 타입의 참조 변수로 자식 클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

### Q. 추상 클래스(abstract class)

A. 추상 클래스(abstract class)는 abstract 키워드를 이용하며 미완성 메서드 즉, 형태만 정의해 놓고 몸체는 없는 상태를 포함하고 있는 클래스를 의미한다.

### Q. 인터페이스(interface)

A. 인터페이스(interface)는 일종의 추상 클래스이다. 인터페이스는 추상 클래스처럼 추상 메서드를 갖지만, 추상 클래스보다 추상화 정도가 높아서 추상 클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.

### Q. String/StringBuffer/StringBuilder

A.

- String: 문자열을 처리하는 자바의 대표적인 클래스이다. 한 번 생성되면 변경이 불가능하며 이유는, 변경이 적고 참조만 많은 경우 혹은 여러 개의 쓰레드(thread)에서 공유하는 문자열일 경우 별다른 동기화(synchronization)를 구현하지 않고 안전하게 공유될 수 있다는 장점이 있기 때문이다. 따라서 String 클래스는 변경이 적고, 단순 참조만 많은 경우에 사용한다.
- StringBuffer/StringBuilder: 새로운 객체를 생성하지 않고 기존 문자열을 변경한다.
  - StringBuffer: 쓰레드의 동기화를 지원 안함 -> 속도가 빠르다.
  - StringBuilder: 쓰레드의 동기화를 지원 -> 속도가 느리다.

### Q. 컬렉션 클래스(collection class) 대표 인터페이스

A.

- list: 순차적으로 데이터를 저장하며 중복을 허용하는 자료구조(data structure)다. -> ArrayList, LinkedList, Stack, Vector
- set: 순서를 유지하지 않고, 데이터의 중복도 허용하지 않는 자료구조다. -> HashSet, TreeSet
- map: 키(key)와 값(value)으로 이루어진 데이터로 순서를 유지하지 않고, 키의 중복만 허용하지 않는 자료구조다. -> HashMap, TreeMap, HashTable

### Q. 제네릭(generic)

A. 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일(compile) 시 타입 체크를 해주는 기능이다.

- 객체의 타입을 컴파일 시 체크 -> 객체의 타입의 안정성을 높이고 형변환의 번거로움이 줄어듦
- 타입의 안정성이 높다는 것 -> 의도하지 않은 타입의 객체가 저장되는 것을 막음
- 형변환의 번거로움이 줄어듦 -> 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄임

### Q. 어노테이션(annotation)

A. 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점을 갖고 있다.

- @Test처럼 프로그램에게 테스트하라고 명령!

### Q. 객체의 직렬화(serialization)

A. 객체에 저장되어 있는 데이터를 스트림(stream)에 바로 쓰기 위해 연속적인 데이터로 변환하는 것을 말한다. 반대로 스트림으로부터 데이터를 읽어 객체로 변환하는 과정을 역직렬화(deserialization)라고 한다.

### Q. 래퍼 클래스(wrapper class)

A. 기본 자료형으로 표현된 데이터를 참조 자료형으로 만들어야 할 경우 래퍼 클래스를 사용한다.

### Q. 자바에서 쓰레드 구현하기 위한 2가지 방법

A.

- lang 패키지(package) 내에 구현 되어있는 Thread 클래스를 상속
- Runnable 인터페이스를 상속받아 run 메서드를 재정의(override)하여 구현

### Q. 람다식(lambda)

A. 람다식은 간단히 말해서 메서드를 하나의 식으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환 값이 없어지므로, 람다식을 익명 함수라고도 한다.

```
// 두 개는 같은 표현

function(int x, int y) {
  return x + y;
}

(int x, int y) -> x + y
```

### Q. 스트림(stream)

A. 스트림(stream)은 데이터 소스(source)를 추상화하고, 데이터를 다루는 데 자주 사용되는 메서드를 정의해 놓은 것이다.

- 데이터 소스 추상화 -> 데이터 소스가 무엇이든 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아지는 것을 의미한다.
- 스트림은 데이터의 흐름 -> 배열 또는 컬렉션 인스턴스에 함수 여러 개를 조합해서 원하는 결과를 필터링 하고, 가공된 결과를 얻을 수 있다.
- 간단한 병렬 처리 가능 -> 하나의 작업을 둘 이상의 작업으로 잘게 나눠서 동시에 진행, 빠르게 처리 가능하다.
- 스트림은 크게 3가지로 나눌 수 있다.

  - 생성하기: 스트림을 이용하기 위해서는 먼저 생성부터!
    - Array.stream: 배열
    - Stream.builder(): 직접 원하는 값을 넣을 수 있음 -> 마지막에 build 메서드로 스트림 리턴
  - 가공하기: 전체 요소 중에서 원하는 것만 뽑을 수 있음!
    - asList: 리스트를 대상
    - Flitering: 스트림 내 요소들을 하나씩 평가해서 걸러내는 작업
    - mapping: 스트림 내 요소들을 하나씩 특정 값으로 변환
  - 결과: 가공한 스트림을 가지고, 사용할 결과 값으로 만들어내는 단계
    - Collectors.toList(): 스트림에서 작업한 결과를 담은 리스트로 반환
    - Collectors.joining(): 작업한 결과를 하나의 스트링으로 이어 붙일 수 있음
    - Collectors.groupingBy(): 특정 조건으로 요소들을 그룹지을 수 있음

- [함께 보면 좋을 것](https://futurecreator.github.io/2018/08/26/java-8-streams/)

### Q. gc(garbage collection)

A. gc는 크게 minor, major로 나뉜다. minor는 new 영역을 대상으로 실행하며, major는 old 영역을 대상으로 실행된다.

- minor: new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제한다. 둘 째로 eden 영역과 survivor2 영역에 기준치 이상으로 찼을 경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 survivor2 영역에 복사 후 나머지 영역의 객체를 삭제한다. 마지막으로 일정시간 이상 참조되고 있는 객체들을 old 영역으로 이동시킨다.
- major: minor에 비해 시간이 오래 걸리며 old 영역이 가득차, 프로세스(process)가 정지될 가능성이 있는 경우 실행된다. old 영역에 있는 모든 객체를 검사하여 참조되지 않는 객체들을 한꺼번에 삭제한다.

### Q. nio(new input-output)

A. 기존의 자바 io의 단점을 보완한 새로운 io 패키지를 의미하며 non-blocking io를 지원하는 특징이 있다.

### Q. call by value/call by reference

A.

- call by value: 값에 의한 호출, 즉 함수에 매개 변수의 내용물을 전달하여 복사해서 사용하는 방식 -> 기존의 값에 영향이 없음
- call by reference: 주소에 의한 호출, 즉 주소를 참조해서 호출하는 방식 -> 변경된 값을 유지

### Q. String 클래스의 intern 메서드/상수 풀(constant pool)

A. 자바에서 쓰이는 모든 String 객체는 상수 풀(constant pool)에서 관리된다. 상수 풀은 객체가 생성되는 영역인 힙(heap)의 permanent generation 영역에 생성되어 자바 프로세스가 종료될 때까지 함께한다. 상수 풀을 이용하여 String을 관리하는 이유는 중복 문자열에 대한 효율적인 메모리(memory) 관리 때문이다. 같은 문자열이 이미 존재하는데 다시 동일한 문자열이 상수 풀에 삽입되려는 경우 삽입을 위해 힙에 생성되었던 문자열을 해제하고 상수 풀에서 관리하는 레퍼런스(reference)로 반환한다. -> 낭비되는 현상 해결

String 클래스의 intern 메서드는 힙 영역에 있는 문자열 객체를 상수 풀로 이전시키는 메서드다. intern 메서드는 실행 후 해당 문자열과 동일한 문자열이 없다면 해당 객체를 상수 풀에 등록하고, 힙 영역에서 해제 후 레퍼런스 값을 반환한다. 만약 해당 문자열과 동일한 문자열이 있다면 해당 객체를 힙 영역에서 해제 후 상수 풀에 있는 해당 문자열의 레퍼런스 값을 반환해준다.

### Q. 메모리 누수(memory leak)

A. 메모리 누수(memory leak)는 더이상 사용하지 않는 객체가 gc에 의해서 회수되지 않고 계속 누적되는 현상이다. old 영역에 누적된 객체로 인해서 major gc가 빈번하게 발생하게 되고, 프로그램의 응답 속도가 늦어지다 결국 오류로 프로그램이 종료된다. 주로 빈번한 전역변수의 선언이나, 리스트(list)나 해쉬맵(hashmap) 같은 컬렉션에 저장한 객체를 해제하지 않고, 계속 유지하게 되면서 주로 발생한다.

### Q. 자바에서의 예외처리

A. 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이다.

### Q. exception/error

A.

- exception: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
- error: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류

### Q. RuntimeException/Exception

A.

- RuntimeException: 주로 프로그래머 실수에 의해서 발생될 수 있는 예외
- Exception: 주로 외부의 영향으로 발생할 수 있는 것
