## Java QnA

### Q. 자바의 장단점
A. 자바의 가장 큰 장점은 JVM을 이용한 플랫폼 독립적이라는 점이다. 자바에서 코드를 컴파일하면 바이트코드(.class) 형태로 출력이된다. 이 바이트코드는 JVM에 런타임에 완벽한 기계어로 변경되어 실행된다. 하나의 바이트코드를 가지고 서로 다른 기계마다 해당 JVM만 설치되어 있으면 다시 컴파일 할 필요 없이 나머지는 JVM에서 해당 운영체제에 맞도록 실행해준다. 그 밖에도 객체지향언어이며, 자동으로 메모리 관리를 해주고, 네트워크 분산 처리 지원, 멀티쓰레드 지원, 동적 로딩을 지원한다.
+ 로딩은 어떤 프로세스를 메모리에 적재하는 것인데, 동적 로딩은 필요한 프로세스만 메모리에 적재하는 것이다.

자바의 단점은 JVM을 사용하는데서 있다. 자바 프로그램이 실행되기 위해서는 먼저 JVM이 실행되어야 하는데 실행과정은 생각보다 많은 메모리를 소모하며 실핵속도 또한 빠르지 않다. 또한 바이트코드를 완전한 기계어로 변환하는 과정에서도 일반적인 컴파일 언어로 작성된 프로그램보다 속도가 느리다.

### Q. JVM
A. JVM은 Java Virtual Machine의 약자로, 자바를 실행하기 위한 가상 기계라고 할 수 있다. 가상 기계는 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어이며, 컴퓨터의 성능이 향상됨에 따라 점점 더 많은 하드웨어들이 소프트웨어화 되어 플레이어라던가, 오디오 시스템을 소프트웨어와한 윈앰프 등이 있다. 자바로 작성된 애플리케이션은 모두 JVM에서 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.

일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달 되는데 비해 Java는 JVM을 한 번 더 거친다. 그래서 Java는 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램 변경없이 실행이 가능한 것이다.

### Q. JDK 주요 실행 파일
A. javac.exe 파일은 자바 컴파일러, 즉 자바 소스코드를 바이트 코드로 컴파일한다. java.exe는 자바 인터프리터로, 컴파일러가 생성한 바이트 코드를 해석하고 실행한다. javap.exe는 역어셈블러로, 컴파일된 클래스 파일을 원래의 소스로 변환한다.
+ jar는 Java Archive, 자바파일 관련 된 것만 압축, war는 Web Application Archive로 jsp, servlet, jar 등 servlet 관련 파일을 압축

### Q. JVM 메모리 구조
A. 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 그중 3가지 주요 영역인 method area, call stack, heap이 있다.
method area는 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이때, 클래스의 클래스 변수도 이 영역에 함께 생성된다.

+ 클래스 변수는 static이 붙은 것, 나머지는 인스턴스 변수

heap은 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
call stack은 메소드의 작업에 필요한 메모리 공간을 제공한다. 메소드가 호출되면, call stack에 호출된 메소드를 위한 메모리가 할당되며, 이 메모리는 메소드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용한다. 그리고 메소드가 작업을 마치면 할당되었던 메모리 공간은 반한 되어 비워진다. 구조가 stack으로 되어있다.

### Q. 기본 자료형과 참조 자료형
A. 기본 자료형은 byte, short, int, long, float, double, char, boolean이 있다. 기본 자료형으로 생성한 변수에는 값 자체가 저장된다. 사용전에 반드시 선언되어야하며 OS에 따라 자료형의 길이가 변하지 않고 null 값을 가질수 없는 특징이 있다.
참조 자료형은 class, interface, array, enum이 있다. 참조 자료형으로 생성한 변수에는 객체의 주소 값이 저장된다. 생성자를 이용하여 새로운 객체의 주소를 가리키거나 null 값을 이용하여 해제할 수 있다.

### Q. 절차적/구조적 프로그래밍
A. 절차적 프로그래밍을 한마디로 표현하자면 goto를 사용하지 않는 것이다. goto를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에 너무 복잡해질 가능성이 있기 때문에 goto를 사용하지 못하게 한 것이다.
구조적 프로그래밍은 함수를 쓰라는 의미이다. 함수를 쓰면 좋은 이유는 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드 즉 클린 코드를 작성할 수 있기 때문이다. 여기에 더해 구조적 프로그래밍의 지침 중에는 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수를 쓰라는 것도 있다.

### Q. 객체지향 프로그래밍
A. 객체지향 프로그래밍은 객체의 관점에서 프로그래밍하는 것을 의미한다. 객체지향언어는 기존의 프로그래밍 언어와 다른 전혀 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다. 이러한 규칙들을 이용해서 코드 간에 서로 관계를 맺어줌으로써 보다 유기적으로 프로그램을 구성하는 것이 가능해졌다.

### Q. 객체지향언어 특징
A. 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있어, 코드의 재사용성이 높다. 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있어 관리가 용이하다. 제어자와 메소드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있어, 신뢰성이 높은 프로그래밍을 가능하게 한다.

### Q. 클래스 / 객체 / 인스턴스
A. 클래스란 객체를 정의해 놓은 것 또는 클래스는 객체의 설계도 또는 틀이라고 정의할 수 있다. 클래스는 객체를 생성하는 데 사용되며, 객체는 클래스에서 정의된 대로 생성된다. 객체의 사전적인 정의는 실제로 존재하는 것이다. 우리가 주변에서 볼 수 있는 책상, 의자, 자동차와 같은 사물들이 곧 객체이다. 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다. 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.

### Q. 객체의 구성요소
A. 객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다. 즉 개체는 속성과 기능의 집합이라고 할 수 있다. 클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어있다. 클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어지는 것이다.

### Q. 오버로딩
A. 메소드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 가져야 한다. 그러나 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면 같은 이름을 사용해서 메소드를 정의할 수 있다. 이처럼, 한 클래스 내에 같은 이름의 메소드를 여러 개 정의하는 것을 오버로딩이라 한다.

### Q. 오버로딩의 조건
A. 같은 이름의 메소드를 정의한다고 해서 무조건 오버로딩인 것은 아니다. 오버로딩이 성립하기 위해서는 조건이 있다. 메소드 이름이 같아야 하며, 매개변수의 개수 또는 타입이 달라야 한다. 비록 메소드의 이름이 같다 하더라도 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능한 것이다. 만일 메소드도 변수처럼 단지 이름만으로 구별된다면, 한 클래스내의 모든 메소드들은 이름이 달라야한다. 하지만 오버로딩이 가능하기 때문에 메소드의 이름을 절약할 수 있다.
+ 반환 타입은 구현하는데 아무런 영향을 주지 못함.

### Q. 생성자
A. 생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드이다. 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다. 생성자 역시 메소드처럼 클래스 내에 선언되며, 구조도 메소드와 유사하지만 리턴값이 없다는 점이 다르다.

### Q. 상속
A. 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다. 이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.

### Q. 오버라이딩
A. 부모 클래스로부터 상속받은 메소드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메소드를 그대로 사용하기도 하지만, 자식 클래스 자신에 맞게 변경해야 하는 경우가 많다. 이럴 때 부모 클래스의 메소드를 오버라이딩 한다고 한다.

### Q. 오버라이딩 조건
A. 오버라이딩은 메소드의 내용만을 새로 작성하는 것이므로 메소드의 선언부는 부모의 것과 완전히 일치해야 한다. 따라서, 메소드 이름이 같아야 하며, 매개변수, 반환타입이 같아야 한다. 한마디로 요약하면 선언부가 일치해야 한다는 것이다. 다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다. 접근 제어자는 부모 클래스의 메소드보다 좁은 범위로 변경할 수 없다. 또한 부모 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

### Q. super
A. super는 자식 클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조 변수이다. 멤버 변수와 지역 변수의 이름이 같을 때 this를 붙여서 구별 했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

### Q. 제어자
A. 제어자는 클래스, 변수 또는 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

### Q. 접근 제어자
A. 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다. private는 같은 클래스 내에서만 접근이 가능하다. default는 같은 패키지 내에서만 접근이 가능하며 protected는 같은 패키지 내에서, 그리고 다른 패키지의 자식 클래스에서 접근이 가능하다. public은 접근 제한이 전혀 없다.

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다. 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다. 이것을 데이터 감추기라고 하며, 객체지향 개념의 캡슐화에 해당하는 내용이다.
+ 만일 메소드 하나를 변경해야 한다고 가정했을 때, 이 메소드의 접근 제어자가 public이라면, 메소드를 변경한 후에 오류가 없는지 테스트해야 하는 범위가 넓다. 그러나 접근 제어자가 default라면 패키지 내부만 확인, private이면 클래스 하나만 살펴보면 된다.

### Q. static
A. 클래스 내부의 메소드나 멤버 변수에 static 키워드를 사용하면 하나의 인스턴스에 속하지 않고 해당 클래스로부터 생성된 모든 인스턴스가 공통으로 공유하는 메소드와 변수로 변경된다.

### Q. final
A. 변수에 final 키워드를 사용하면 해당 변수를 상수화한다. final 키워드가 붙어있는 변수는 초기화만 가능하며 이후 새로운 값으로 변경이나 재할당이 불가능하다. 다음으로 클래스에 final 키워드를 사용하면 해당 클래스를 상속할 수 없다. 마지막으로 메소드에 final 키워드를 사용하면 오버라이딩 할 수 없다.

### Q. getter / setter
A. get으로 시작하는 메소드는 단순히 멤버 변수의 값을 반환하는 일을 하고, set으로 시작하는 메소드는 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버 변수의 값을 변경하도록 작성되어 있다. 만일 상속을 통해 확장될 것이 예상되는 클래스라면 멤버에 접근 제한을 주되 자손 클래스에서 접근하는 것이 가능하도록 하기 위해 private 대신 protected를 사용한다. 

### Q. 다형성 (Polymorphism)
A. 객체지향 개념에서 다형성이란 여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현했다. 이를 좀 더 구체적으로 말하면, 부모 클래스 타입의 참조 변수로 자식 클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

### Q. abstract class
A. 추상 클래스는 abstract 키워드를 이용하며 미완성 메소드 즉, 형태만 정의해 놓고 몸체는 없는 상태를 포함하고 있는 클래스를 의미한다. 추상 클래스는 상속에 큰 의미를 두고 있다. 클래스이기 때문에 extends 키워드를 이용하여 상속을 진행하며 이런 추상 클래스를 상속받은 자식 클래스에서는 반드시 미완성 메소드를 재정의 해야한다.

### Q. Interface
A. 인터페이스는 일종의 추상 클래스이다. 인터페이스는 추상 클래스처럼 추상 메소드를 갖지만 추상 클래스보다 추상화 정도가 높아서 추상 클래스와 달리 몸통을 갖춘 일반 메소드 또는 멤버 변수를 구성원으로 가질 수 없다. 오직 추상 메소드와 상수만을 멤버로 가질 수 있으며 그 외의 다른 어떠한 요소도 허용하지 않는다. 일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 제약사항이 있다.

### Q. String / StringBuffer / StringBuilder
A. String은 문자열을 처리하는 자바의 대표적인 클래스다. String 클래스는 한번 생성되면 변경이 불가능한 immutable 성격을 가지고 있다. String 클래스가 immutable한 이유는 변경이 적고 참조만 많은 경우 혹은 여러 개의 쓰레드에서 공유하는 문자열일 경우 별다른 동기화를 구현하지 않고 안전하게 공유될 수 있다는 장점이 있기 때문이다. 하지만 문자열을 변형하는 경우가 많은 경우 매번 새로운 String 객체가 생성되기 때문에 메모리와 속도 측면에서 비효율적이다. 따라서 String 클래스는 변경이 적고 단순 참조만 많은 경우에 사용한다.
StringBuffer 클래스와 StringBuilder 클래스는 새로운 객체를 생성하지 않고 기존 문자열을 변경한다. 단, StringBuilder의 경우 쓰레드의 동기화를 지원하지 않기 때문에 쓰레드에서 사용하기 위해서는 StringBuffer 클래스를 이용해야한다. 하지만 속도는 동기화를 처리하지 않는 StringBuilder 클래스가 동기화를 처리하는 StringBuffer 클래스보다 빠르기 때문에 쓰레드를 사용하지 않는 환경에서는 StringBuilder 클래스를 사용하는 편이 유리하다.

### Q. 컬렉션 클래스의 대표 인터페이스
A. 컬렉션 클래스는 크게 list, set, map이 있다. list는 순차적인 데이터를 저장하며 중복을 허용하는 자료구조이다. arraylist, linkedlist, stack, vactor가 하위 클래스로 존재한다. set은 순서를 유지하지 않고 데이터의 중복만 허용하지 않는 자료구조이다. hashset, treeset이 하위 클래스로 존재한다. map은 키와 값으로 이루어진 데이터를 순서를 유지하지 않고 키의 중복만 허용하지 않는 자료구조이다. hashmap, treemap, hashtable, properties가 하위 클래스로 존재한다.

### Q. 제네릭
A. 제네릭은 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다. 타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다는 의미이다.

### Q. 어노테이션
A. 어노테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다. 예를 들어, 자신이 작성한 소스 코드 중에 특정 메소드만 테스트하기를 원한다면, @Test라는 어노테이션을 메소드 앞에 붙인다. @Test는 이 메소드를 테스트해야 한다는 것을 테스트 프로그램에게 알리는 역할을 할 뿐, 메소드가 포함된 프로그램 자체에는 아무런 영향을 미치지 않는다.

### Q. 객체의 직렬화 (Serialization)
A. 객체에 저장되어 있는 데이터를 스트림에 바로 쓰기 위해 연속적인 데이터로 변환하는 것을 말한다. 반대로 스트림으로부터 데이터를 읽어 객체로 변환하는 과정은 역직렬화라고 한다. IO 패키지 내에 구현되어 있는 Serializable  인터페이스를 상속 받으면 직렬화가 가능한 클래스로 변경할 수 있다. 직렬화를 시키고자하는 클래스에 직렬화가 안되는 객체가 포함 되어있을 경우 transient 키워드를 이용하여 해당 객체를 직렬화 대상에서 제외시킬 수 있다.

### Q. 래퍼 클래스 (Wrapper Class)
A. 기본 자료형으로 표현된 데이터를 참조 자료형으로 만들어야 할 경우 래퍼 클래스를 사용한다. 보통 특정 메소드에서 참조 자료형을 인자로 받거나, 기본 자료형이 아닌 객체 자료형으로 저장해야할 경우, 객체간 비교가 필요할 경우 사용한다.

### Q. 자바에서 쓰레드 구현하기 위한 2가지 방법
A. lang 패키지 내에 구현되어있는 Thread 클래스를 상속받거나 Runnable 인터페이스를 상속받아 run 메소드를 재정의하여 구현한다.

### Q. 람다식
A. 람다식은 간단히 말해서 메소드를 하나의 식으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다. 메소드를 람다식으로 표현하면 메소드의 이름과 반환 값이 없어지므로, 람다식을 익명 함수라고도 한다.

### Q. 스트림
A. 스트림은 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메소드들을 정의해 놓았다. 데이터 소스를 추상화했다는 것은, 데이터 소스가 무엇이든 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다. 스트림을 이용하면, 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방식으로 다룰 수 있다.

### Q. JVM 메모리 구조 추가
A. JVM의 메모리 구조는 크게 class, stack, heap, native 메소드, PC 레지스터로 나뉜다.
class 영역에는 클래스, 변수, 메소드, 상수, static 변수에 대한 정보가 저장된다. stack 영역은 메소드 호출에 따른 메소드를 위한 공간인 프레임이 생성되어 메소드 안에서 필요한 각종 값이 임시로 저장된다. 메소드의 수행이 끝나면 프레임별로 삭제가 진행된다.
heap 영역에는 new 연산자로 생성된 객체와 배열이 저장되는 공간이다. 크게 permanent generation, new, old 영역으로 나뉜다. permanent generation 영역에 생성된 객체들의 주소 값이 저장된다. new 영역은 다시 eden, survivor 영역으로 나뉜다. eden에는 객체들이 최초로 생성되는 영역이며 survivor는 eden 영역에서 참조되는 객체들이 저장되는 영역이다. 마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간이다.
native 메소드 영역은 자바 이외의 다른 언어에서 제공되는 메소드가 저장되는 영역이며, PC 레지스터 영역은 쓰레드가 생성될 때마다 생성되는 영역으로 쓰레드가 어떤 명령을 실행할지 저장한다.

### Q. Garbage Collection
A. GC는 크게 minor, major로 나뉜다. minor에서는 new 영역을 대상으로 실행된다. 첫째로 new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제한다. 둘째로 eden 영역과 servivor1 영역이 기준치 이상으로 찼을 경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 survivor2 영역에 복사 후 나머지 영역의 객체를 삭제한다. 마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킨다.
major에서는 old 영역을 대상으로 실행된다. minor에 비해 시간이 오래 걸리며 old 영역이 가득 차, 프로세스가 정지될 가능성이 있는 경우 실행된다. old 영역에 있는 모든 객체를 검사하여 참조되지 않은 객체들을 한꺼번에 삭제한다.

### Q. NIO(new input-output)
A. 기존의 자바 IO의 단점을 보완한 새로운 IO 패키지를 의미하며 non-blocking IO를 지원하는 특징이 있다.

### Q. Call by value / Call by reference
A. Call by value는 값에 의한 호출, 즉 함수에 매개 변수의 내용물을 전달 하여 복사해서 사용하는 방식이다. 따라서 기존의 값에 영향을 끼치지 않는다. Call by reference는 주소에 의한 호출, 즉 주소를 참조해서 호출하는 방식이다. 매개 변수의 주소를 호출하여 함수가 끝나도 주소는 남아 있기에 값이 변경됐을 때, 함수가 끝나도 변경된 값을 유지하고 있는 것이다.

### Q. 자바 형변환 (업캐스팅, 다운캐스팅)
A. 형변환에는 크게 2가지가 존재한다. 첫 번째로 묵시적 형변환으로 자바에서는 작은 단위를 큰 단위로 바꾸는 경우 묵시적 형변환을 지원한다. 예를 들어, 하위 객체를 상위 객체로 변환하거나 int형 변수를 double형 변수로 변환할 수 있다. 두 번째로 명시적 형변환으로 큰 단위에서 작은 단위로 바꾸는 경우 명시적 형변환을 프로그래머가 정의해주어야한다. 이 경우 데이터의 일부가 유실될 수 있다.

### Q. String 클래스의 intern 메소드 / 상수 풀 (constant pool)
A. 자바에서 쓰이는 모든 String 객체는 상수 풀에서 관리된다. 상수 풀은 객체가 생성되는 영역인 heap의 permanent generation 영역에 생성되어 자바 프로세스가 종료될 때까지 함께한다. 상수 풀을 이용하여 String을 관리하는 이유는 중복 문자열에 대한 효율적인 메모리 관리 때문이다. 같은 문자열이 이미 존재하는데 다시 동일한 문자열이 상수 풀에 삽이되려는 경우 삽입을 위해 heap에 생성되었던 문자열을 해제하고 상수 풀에서 관리하는 래퍼런스로 반환한다. 이렇게 함으로써 동일한 문자열로 인해 메모리가 낭비되는 현상을 해결한다.

String 클래스의 intern 메소드는 heap 영역에 있는 문자열 객체를 상수 풀로 이전시키는 메소드이다. intern 메소드는 실행 후 해당 문자열과 동일한 문자열이 없다면 해당 객체를 상수 풀에 등록하고 heap 영역에서 해제 후 레퍼런스 값을 반환한다. 만약 해당 문자열과 동일한 문자열이 있다면 해당 객체를 heap 영역에서 해제 후 상수 풀에 있는 해당 문자열의 레퍼런스 값을 반환해준다.

### Q. String 생성 방법
A. String 객체를 생성하는 방법에는 크게 2가지가 있다.  첫 번째로 리터럴(“”)을 이용한 방법이다. 이 경우 내부적으로 String 생성자로 객체를 heap 영역에 생성한 후 intern 메소드가 호출되어 상수 풀에 해당 객체를 등록하는 과정을 거친다. 두 번째로 String 생성자를 이용하는 방법이 있다. 이 경우 heap의 어떤 영역에 단순한 인스턴스로 저장한다. 이 경우 상수 풀에 등록되지 않는다. 후에 명시적으로 intern 메소드를 호출하여 상수 풀로 옮겨줄 수 있다.
상수 풀에 등록되어있는 문자열 객체의 경우 == 연산자를 이용하면 바로 두 문자열이 같은지 확인할 수 있다. 하지만 String 생성자를 이용해 heap의 한 영역에 생성된 문자열 객체의 경우 ==로 비교할 수 없다. 두 문자열 객체의 레퍼런스 값이 다르기 때문에 이 경우 String 클래스의 equals를 이용하여 두 문자열의 값을 비교할 수 있다.

### Q. 메모리 누수
A. 메모리 누수는 더이상 사용하지 않는 객체가 GC에 의해서 회수되지 않고 계속 누적되는 현상이다. Old 영역에 누적된 객체로 인해서 major GC가 빈번하게 발생하게 되고, 프로그램의 응답속도가 늦어지다 결국 오류로 프로그램이 종료된다. 주로 빈번한 전역변수의 선언이나, 리스트나 해쉬맵 같은 컬렉션에 저장한 객체를 해제하지 않고 계속 유지하게 되면서 주로 발생한다.

### Q. java.lang.ref 패키지 내에 있는 강참조 / 약참조
A. Strong Reference는 일반적으로 new를 통해서 객체를 생성하게 되면 생기게 되는 참조이다. 강한 참조를 통해 참조되고 있는 객체는 GC의 대상에서 제외된다. Weak Reference는 GC가 발생하면 무조건 삭제된다. 약한 참조가 사라지는 시점이 GC의 실행 주기와 일치하며 이를 이용하여 짧은 주기에 자주 사용되는 객체를 캐시할 때 유용하다.

### Q. JIT (Just In Time)
A. 본래의 소스코드를 컴파일해서 바이트코드로 변환하고, 자바 인터프리터가 바이트코드를 기계어로 해석하고 실행한다. 이 작업은 비용이 많이 들기 때문에 바이트코드를 하드웨어의 기계어로 바로 변환해주는 것이 JIT이다. JIT 컴파일러는 같은 코드를 매번 해석하는 대신 자주 쓸만한 코드를 컴파일 해두고 사용한다. 이로써 인터프리터의 느린 실행 속도를 개선해 줄 수 있다. 하지만 초기 실행 속도나 메모리 부분에서 약간의 단점이 있다.

### Q. JDK와 JRE
A. JDK는 자바를 개발하기 위한 환경으로 JRE를 포함한다. JRE는 Java Runtime Enviroment의 약자로 자바를 실행시키기 위한 환경으로 JVM을 포함한다.

### Q. Exception / Error
A. 런타임 에러를 방지하기 위해서는 프로그램의 실행도중 발생할 수 있는 모든 경우의 수를 고려하여 이에 대한 대비를 하는 것이 필요하다. 자바에서는 실행 시 발생할 수 있는 프로그램 오류를 Error와 Exception으로 구분한다. Error는 프로그램 코드에 의해서 수습될 수 없는 심각한 오류이며, Exception은 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류이다.

### Q. RuntimeException과 RE가 아닌 것
A. RuntimeException의 클래스들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다. 예를 들면, 배열의 범위를 벗어난다던가, 값이 null인 참조 변수의 멤버를 호출하려 했다던가 등등
Exception 클래스들은 주로 외부의 영향으로 발생할 수 있는 것들로써, 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다. 예를 들어, 존재하지 않는 파일의 이름을 입력했다던가 등등

### Q. 자바에서의 예외처리
A. 프로그램 실행 도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다. 예외처리란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행중인 프로그램의 갑작스러운 비정상 종료를 막고, 정상적인 실행 상태를 유지할 수 있도록 하는 것이다.
